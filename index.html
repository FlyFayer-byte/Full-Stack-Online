<!DOCTYPE html>
<!-- Вказує браузеру, що документ написано на HTML5 -->
<html lang="uk">
  <!-- Початок HTML-документа, атрибут lang="uk" вказує мову сторінки — українську -->
  <head>
    <meta charset="UTF-8" />
    <!-- Вказує кодування символів для документа, UTF-8 підтримує українські літери -->
    <!-- Забезпечити сумісність з Internet Explorer -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <!-- Встановити масштабування для мобільних пристроїв -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/modern-normalize@2.0.0/modern-normalize.min.css"
    />
    <!-- Підключити Modern Normalize для скидання стилів -->
    <link rel="stylesheet" href="./css/styles.css" />
    <!-- Підключення зовнішнього CSS-файлу для стилізації сторінки -->
    <title>Fullstack developer</title>
    <!-- Назва сторінки у вкладці браузера -->
  </head>
  <body>
    <!-- Основний вміст сторінки, який бачить користувач -->
    <!-- Тут буде розміщено меню, розділи та контент -->
    <aside class="sidebar-menu">
      <!-- Бокова панель навігації -->
      <div class="sidebar-wrapper">
        <ul class="sidebar-list">
          <li class="sidebar-item">
            <a class="sidebar-link" href="#modul-1">Основи HTML</a>
          </li>
          <li class="sidebar-item">
            <a class="sidebar-link" href="#modul-2">Вступ до CSS</a>
          </li>
          <li class="sidebar-item">
            <a class="sidebar-link" href="#modul-3">Блокова модель</a>
          </li>
          <li class="sidebar-item">
            <a class="sidebar-link" href="#modul-4">Декоративні ефекти</a>
          </li>
          <li class="sidebar-item">
            <a class="sidebar-link" href="#modul-5">Елементи форм</a>
          </li>
          <li class="sidebar-item">
            <a class="sidebar-link" href="#modul-6">Адаптивний дизайн</a>
          </li>
        </ul>
      </div>
    </aside>
    <section class="container">
      <!-- Основний контейнер для контенту сторінки -->
      <h1 class="side-title">Fullstack developer</h1>

      <!-- Модуль 1. Основи HTML -->
      <div class="container-content">
        <!-- Основний контент -->
        <h2 id="modul-1" class="container-title">Модуль 1. Основи HTML</h2>
        <!-- Розділ з основами HTML -->
      </div>

      <!-- Модуль 2. Вступ до CSS -->
      <div class="container-content">
        <!-- Основний контент -->
        <h2 id="modul-2" class="container-title">Модуль 2. Вступ до CSS</h2>
        <!-- Розділ з основами HTML -->
      </div>

      <!-- Модуль 3. Блокова модель. Flexbox -->
      <div class="container-content">
        <!-- Основний контент -->
        <h2 id="modul-3" class="container-title">
          Модуль 3. Блокова модель. Flexbox
        </h2>
        <!-- Розділ з основами HTML -->
      </div>

      <!-- Модуль 4. Декоративні ефекти -->
      <div class="container-content">
        <!-- Основний контент -->
        <h2 id="modul-4" class="container-title">
          Модуль 4. Декоративні ефекти
        </h2>
        <!-- Розділ з основами HTML -->
      </div>

      <!-- Модуль 5. Елементи форм. Доступність -->
      <div class="container-content">
        <!-- Основний контент -->
        <h2 id="modul-5" class="container-title">
          Модуль 5. Елементи форм. Доступність
        </h2>
        <div>
          <h3>Програма модулю</h3>

          <h4>Цілі модуля 5:</h4>
          <ul>
            <li>розуміти що таке і як працюють HTML-форми</li>
            <li>
              розрізняти основні типи елементів у формах (form, label, input
              тощо)
            </li>
            <li>стилізувати форми на сторінці</li>
            <li>вміти групувати пов'язані елементи форм</li>
            <li>створювати різні типи форм</li>
            <li>
              застосовувати набір спеціальних псевдокласів для елементів форм
            </li>
          </ul>

          <h3>Форми</h3>
          <p>
            HTML-форми — це елементи веб-сторінки, які дозволяють користувачам
            вводити дані та надсилати їх на сервер для обробки. Вони складаються
            з різних елементів, таких як текстові поля, кнопки, списки тощо.
          </p>
          <h4>HTML-форма</h4>
          <p>
            HTML-форма — це контейнер для елементів, які дозволяють користувачам
            вводити дані. Вона визначається тегом <code>&lt;form&gt;</code>.
            Атрибут <code>action</code> вказує URL, куди будуть надіслані дані
            форми, а атрибут <code>method</code> визначає метод надсилання даних
            (наприклад, GET або POST).
          </p>
          <p>
            Форми на веб-сторінці — це аналог паперової форми, анкети чи бланка.
            Вони дозволяють отримувати інформацію від відвідувачів веб-сторінки.
            Списки розсилки, контактні дані, профіль користувача, логін і
            реєстрація, коментарі в блогах — усе це реалізується за допомогою
            форм та їх елементів.
          </p>
          <img src="./images/modul_5/Frame 48434.jpg" alt="HTML-форма" />
          <p>Функціональна HTML-форма складається з двох частин:</p>
          <ol>
            <li>Інтерфейс користувача (фронтенд сторінки).</li>
            <li>Сервер (бекенд сторінки).</li>
          </ol>
          <p>
            Перше – це зовнішній вигляд форми (розмітка та оформлення).<br />
            Друге – код обробки введених даних (валідація, зберігання даних,
            відправлення електронної пошти тощо).
          </p>
          <img
            src="./images/modul_5/e331d063-9686-48a6-93c0-274dc56c4858Frame 48436.png"
            alt="forms"
          />

          <h4>Елемент <code>form</code></h4>
          <p>
            Елемент <code>form</code> — це розділ HTML-документа, що містить
            інтерактивні елементи керування, які дозволяють користувачеві
            надсилати інформацію на веб-сервер.
          </p>
          <div class="ql-syntax-block">
            <pre
              class="ql-syntax hljs language-xml"
              spellcheck="false"
              data-highlighted="yes"
            ><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"feedback_form"</span> <span class="hljs-attr">autocomplete</span>=<span class="hljs-string">"off"</span> <span class="hljs-attr">novalidate</span>&gt;</span>
            <span class="hljs-comment">&lt;!-- Елементи форми --&gt;</span>
          <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
          </pre>
            <button class="copy"></button>
          </div>
        </div>
      </div>

      <!-- Модуль 6. Адаптивний дизайн -->
      <div class="container-content">
        <!-- Основний контент -->
        <h2 id="modul-6" class="container-title">
          Модуль 6. Адаптивний дизайн
        </h2>
      </div>
    </section>
  </body>
</html>
<!-- Кінець HTML-документа -->

<!--<aside class="menu">-->
<!-- Бокова панель навігації -->
<!--<div>
        <ul class="menu-list">
          <li>
            <a class="header-list-item" href="#menu-item--html-basics"
              >Основи HTML</a
            >
          </li>
          <li>
            <a class="header-list-item" href="#menu-item--css-intro"
              >Вступ до CSS</a
            >
          </li>
          <li>
            <a class="header-list-item" href="#menu-item--box-model"
              >Блокова модель</a
            >
          </li>
          <li>
            <a class="header-list-item" href="#menu-item--effects"
              >Декоративні ефекти</a
            >
          </li>
          <li>
            <a class="header-list-item" href="#menu-item--form-elements"
              >Елементи форм</a
            >
          </li>
          <li>
            <a class="header-list-item" href="#menu-item--responsive"
              >Адаптивний дизайн</a
            >
          </li>
        </ul>
      </div>
    </aside>
    <h1>Fullstack developer</h1>-->
<!--Модуль 1. Основи HTML-->
<!--<section class="container">
      <div>
        <h2 class="container-title">Основи HTML</h2>
      </div>
    </section>
  -->
<!--------------------------------------------------------------------------------------------->
<!--<h1>Модуль 1. Основи HTML</h1>
    <section>-->
<!--Веб-технології-->
<!--<h2 id="menu-item--html-basics">Веб-технології</h2>
      <div>-->
<!--Веб-технології HTML, CSS, JS-->
<!--<h3>Веб-технології HTML, CSS, JS</h3>
        <p class="ql-align-justify">
          Вебсайти – це основа, на якій тримається інтернет. І всі вони
          побудовані на трьох основних технологіях. Використання однієї
          технології не виключає всіх інших. Навпаки, вони зазвичай
          використовуються разом.&nbsp;
        </p>
        <ul>
          <li class="ql-align-justify">
            <strong>HTML</strong> - відповідає за наповнення веб-сторінки
            контентом, а також за її структуру та вміст. Це, наприклад, статті,
            світлини та відео розміщені на сайтах.&nbsp;
          </li>
          <li class="ql-align-justify">
            <strong>CSS</strong>&nbsp; - використовується для оформлення та
            позиціонування елементів сторінки, тобто забезпечення її зовнішнього
            вигляду. Отже, розробник має знати CSS, щоб додавати різні шрифти,
            фон, або спеціальні ефекти для окремих блоків.
          </li>
          <li class="ql-align-justify">
            <strong>JavaScript</strong> - дозволяє додавати функціонал чи
            реакцію на дії користувача. Це вже не про ефекти, зміни кольору при
            наведенні на кнопку, а про функціональну фічу на сайті: наприклад,
            користувач заповнює форму реєстрації тощо.
          </li>
        </ul>
        <img
          src="./images/modul_1/1961a244-0383-4e08-a9f7-14475bccf9d6Frame 47826.png"
          alt="HTML, CSS, JAVASCRIPT"
        />-->
<!--Що таке мова HTML?-->
<!--<h3>Що таке мова HTML?</h3>
        <p>
          <strong>HyperText Markup Language</strong> (мова розмітки гіпертексту)
          - мова розмітки веб-документів. Набір правил структурування (розмітки)
          текстової інформації, додавання зображень, створення таблиць, форм,
          списків тощо.
        </p>
        <p>
          <strong>HTML-документ</strong> - текстовий файл з розширенням
          <code>.html</code>.
        </p>
      </div>-->
<!--Теги та атрибути-->
<!--<h2>Теги та атрибути</h2>
      <div>-->
<!--Теги-->
<!--<h3>Теги</h3>
        <p>
          <strong>Тег (tag)</strong> - елемент мови розмітки гіпертексту. Теги є
          найменшими будівельними блоками, з яких складається будь-яка
          веб-сторінка. Кожен тег позначає окрему сутність: заголовок, список,
          абзац тексту, зображення. Для виділення тегів у тексті документа
          використовуються кутові дужки, у яких вказується ім'я тегу та його
          атрибути.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-bnf"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-attribute">&lt;ім'я_тегу&gt;</span>...<span class="hljs-attribute">&lt;/ім'я_тегу&gt;</span></pre>
        </div>
        <p>
          Відкриваючий тег вказує на початок елементу, закриваючий — на його
          закінчення. Закриваючий тег утворюється шляхом додавання слешу
          (<code>/</code>) перед ім'ям тегу. Між відкриваючим та закриваючим
          тегами знаходиться контент тегу.
        </p>
        <pre class="ql-blockquote" spellcheck="false">
HTML елемент — це абзац, заголовок, список, посилання тощо. У HTML-документі елемент складається з тегу та контенту тегу.&nbsp;</pre
        >-->
<!--Тег абзацу-->
<!--<h3>Тег абзацу</h3>
        <p>
          Тег <code>&lt;p&gt;</code> - універсальний контейнер для групування
          дрібних фразових елементів, відокремлення їх один від одного й
          подальшої стилізації. За замовчуванням тег абзацу
          <code>&lt;p&gt;</code>
          - це блоковий елемент, який починається з нового рядка і має
          вертикальні відступи, які можна буде змінити за допомогою CSS.
        </p>
        <p>
          Часто буває необхідно заповнити тег текстом, але самого тексту, який
          розміщуватиметься на сайті, ще немає. Для цього використовують
          спеціальний заповнювач (текст-риба).
        </p>
        <pre class="ql-blockquote" spellcheck="false">
У редакторі VSCode, в HTML-документі можна набрати код <code>lorem10</code>, після чого натиснути клавішу <code>Tab</code>. Це створить масив тексту із 10 слів. Замість 10 можна встановити будь-яке число.</pre
        >-->
<!--Тег заголовка-->
<!-- <h3>Тег заголовка</h3>
        <p>
          Заголовок є інструментом структурування текстового вмісту сторінки.
          Для того, щоб додати найважливіший заголовок, що описує весь вміст
          сторінки, використовується тег <code>&lt;h1&gt;</code> - заголовок
          першого рівня. На практиці тег&nbsp;<code>&lt;h1&gt;</code>
          використовується лише один раз як основний заголовок сторінки.
        </p>
        <pre
          class="ql-blockquote"
          spellcheck="false"
        ><strong>Оформлення коду</strong> 
Запам’ятай основне:
  - кожен тег починається з нового рядка; 
  - якщо контент займає кілька рядків, відкриваючий та закриваючий теги розташовані один під одним; 
  - якщо контент займає один рядок, відкриваючий та закриваючий теги розташовані безпосередньо до та після контенту. 
  Це забезпечує кращу візулізацію початку та кінця тегу.</pre>
        Коментарі
        <h3>Коментарі</h3>
        <p>Коментарі використовуються для того, щоб:</p>
        <ul>
          <li>залишити у вихідному коді пояснення, нотатку;</li>
          <li>
            візуально розділити код, позначивши, де починається і закінчується
            розмітка шапки сайту, підвала, окремої секції тощо;
          </li>
          <li>
            закоментувати ділянку коду, тобто тимчасово приховати частину
            HTML-коду, щоб вона не відображалася на сторінці в браузері.
          </li>
        </ul> -->
<!--Атрибути: тег посилання <a> та його атрибут href-->
<!-- <h3>
          <strong class="ql-size-large">Атрибути: тег посилання </strong
          ><code class="ql-size-large"><strong>&lt;a&gt;</strong></code
          ><strong class="ql-size-large"> та його атрибут </strong
          ><code class="ql-size-large"><strong>href</strong></code>
        </h3>
        <p>
          <strong>Атрибути</strong> - це додаткові налаштування тегів, за
          допомогою яких можна змінювати властивості та поведінку елементу. Теги
          можуть мати обов'язкові та необов'язкові атрибути. Їх може бути
          декілька або зовсім не бути.
        </p>
        <p>
          Атрибути записуються всередині відкриваючого тегу, а їх значення
          вказуються всередині подвійних лапок. Декілька атрибутів розділяються
          пробілом.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-routeros"
            spellcheck="false"
            data-highlighted="yes"
          >&lt;a <span class="hljs-attribute">href</span>=<span class="hljs-string">"https://google.com"</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">"link"</span>&gt;...&lt;/a&gt;
&lt;img <span class="hljs-attribute">src</span>=<span class="hljs-string">"cat.jpg"</span> <span class="hljs-attribute">alt</span>=<span class="hljs-string">"cute cat"</span>&gt;
&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attribute">name</span>=<span class="hljs-string">"user_name"</span>&gt;
&lt;button <span class="hljs-attribute">type</span>=<span class="hljs-string">"submit"</span>&gt;...&lt;/button&gt;</pre>
          <pre class="ql-blockquote" spellcheck="false">Корисно! 
Для того, щоб дізнатися які атрибути доступні для тегу та призначення атрибутів, можна зайти в документацію або довідник, наприклад <a href="http://htmlreference.io/" rel="noopener noreferrer" target="_blank">htmlreference.io</a></pre>
        </div>
        <p>
          Давай розглянемо структуру тегу з атрибутами на прикладі тегу
          <code>&lt;a&gt;</code>. Він призначений для створення посилань або
          тексту. Клікаючи по ньому, ми переходимо на іншу сторінку,
          завантажуємо файл тощо. Текст посилання відображається в браузері з
          підкресленням синім шрифтом. При наведенні на посилання курсор миші
          змінює вигляд.
        </p>
        <img
          src="./images/modul_1/f8859b1b-5eff-4ebb-8939-a9a5d941378eFrame 47552.png"
          alt="Структуру тегу &lt;a&gt; з атрибутами"
        />
        <p>
          Адреса посилання задається в обов'язковому атрибуті
          <code>href="адреса"</code>, де адреса - це URL, що вказує на сторінку,
          файл або будь-який ресурс.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-xml"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://google.com"</span>&gt;</span>Посилання на головну сторінку Google<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></pre>
          <p>
            <strong>URL</strong> (скорочення від Uniform Resource Locator) -
            унікальна сукупність символів, в якій відображається шлях до
            сторінки інтернет-ресурсу, наприклад
            <a
              href="https://goit.global/"
              rel="noopener noreferrer"
              target="_blank"
              >https://goit.global/</a
            >.
          </p>
          <pre
            class="ql-blockquote"
            spellcheck="false"
          ><strong>Запам’ятай основні характеристики атрибутів:</strong>
- Атрибути змінюють або надають додаткові властивості тегам. 
- Кілька атрибутів у тегу відокремлюються за допомогою пробілу. 
- Атрибути та їх значення містяться всередені відкриваючого тегу. 
- Знак “=” ставиться між атрибутом та його значенням.</pre>
        </div> -->
<!--Посилання: атрибут target-->
<!-- <h3>
          <strong class="ql-size-large">Посилання: атрибут </strong
          ><code class="ql-size-large"><strong>target</strong></code>
        </h3>
        <p>
          Якщо ми хочемо, щоб веб-сторінка, до якої веде посилання, відкривалася
          в новій вкладці браузера, необхідно додати тегу
          <code>&lt;a&gt;</code> атрибут <code>target="_blank"</code>.
        </p>
        <p>
          За замовчуванням посилання відкриваються у поточній вкладці браузера,
          а значення атрибуту <code>target</code>за замовчуванням є
          <code>target="_self"</code>
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-xml"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-comment">&lt;!-- 
  Посилання на зовнішній ресурс, відкриється на поточній вкладці 
--&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://goit.global/"</span>&gt;</span>GoIT<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
        
<span class="hljs-comment">&lt;!-- 
  Посилання на зовнішній ресурс, відкриється на новій вкладці 
--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://goit.global/"</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span>&gt;</span>
  GoIT
<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></pre>
        </div> -->
<!--Тег <img> і його атрибут src-->
<!-- <h3>
          <strong class="ql-size-large">Тег </strong
          ><code class="ql-size-large"><strong>&lt;img&gt;</strong></code
          ><strong class="ql-size-large"> і його атрибут </strong
          ><code class="ql-size-large"><strong>src</strong></code>
        </h3>
        <p>
          <strong>Растрова графіка (raster, bitmap)</strong> - опис графічного
          файлу у вигляді масиву з координатами кожного пікселя і описом кольору
          цього пікселя. Це як мапа кольорів з фіксованим розміром.
        </p>
        <p>Два формати зображень, що найбільш широко використовуються:</p>
        <ul>
          <li>
            <strong>JPEG</strong> - великі файли, що не потребують прозорого
            фону або анімації. Цей формат ідеальний для яскравих реалістичних
            фотографій, оскільки вони можуть містити мільйони кольорів.
          </li>
          <li>
            <strong>PNG</strong> - на відміну від JPEG, підходить для зображень,
            фон яких має бути прозорим або одноколірним. Використовується для
            іконок та декоративних елементів. Також цей формат використовується
            для зображень підвищеної точності: скріншотів, креслень, графіків
            тощо.
          </li>
        </ul>
        <p>
          Тег <code>&lt;img&gt;</code> призначений для розмітки зображень у
          різних графічних форматах.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-stylus"
            spellcheck="false"
            data-highlighted="yes"
          >&lt;<span class="hljs-selector-tag">img</span> <span class="hljs-attribute">src</span>=<span class="hljs-string">"https://images.pexels.com/photos/67112/pexels-photo-67112.jpeg"</span>&gt;</pre>
        </div>
        <p>
          Щоб задати адресу зображення, використовується обов'язковий атрибут
          <code>src="шлях"</code>.
        </p> -->
<!--Зображення: атрибут alt-->
<!-- <h3>
          <strong class="ql-size-large">Зображення: атрибут </strong
          ><code class="ql-size-large"><strong>alt</strong></code>
        </h3>
        <p>
          У разі якщо зображення не завантажилося, або для користувачів з
          обмеженим зором слід додавати значущу інформацію щодо зображень.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-abnf"
            spellcheck="false"
            data-highlighted="yes"
          >&lt;img
  src<span class="hljs-operator">=</span><span class="hljs-string">"https://images.pexels.com/photos/67112/pexels-photo-67112.jpeg"</span>
  alt<span class="hljs-operator">=</span><span class="hljs-string">"Macbook Air на сірому дерев'яному столі"</span>
&gt;</pre>
        </div>
        <p>
          Альтернативний текст має бути у кожному тегу
          <code>&lt;img&gt;</code>.
        </p>
        <ul>
          <li>- В описі має бути закінчене, повністю сформульоване речення.</li>
          <li>
            - Альтернативний текст повинен відповідати на питання «Що зображено
            малюнку?».
          </li>
          <li>
            - Опис має бути унікальним і не повторювати те, що є в тексті до
            цього зображення.
          </li>
          <li>
            - В описі не потрібно використовувати слова "зображення", "картинка"
            або "ілюстрація", це само собою зрозуміло.
          </li>
        </ul> -->
<!--Зображення: атрибути width та height-->
<!-- <h3>
          <strong class="ql-size-large"
            >Зображення: атрибути <code>width</code> та
            <code>height</code></strong
          >
        </h3>
        <p>
          За замовчуванням браузер відображає будь-яке зображення (картинки,
          фото, схеми) в оригінальному розмірі.
        </p>
        <p>
          Для того щоб змінити розміри картинки, тег
          <code>&lt;img&gt;</code> має атрибути <code>width</code>і
          <code>height</code> . Вони відповідають за ширину і висоту елементу
          зображення в браузері. Значення задаються в пікселях, тобто точках на
          екрані. В коді вказується лише число, без позначення
          <code>px</code> (див. приклад нижче).
        </p>
        <p>
          Якщо встановити лише одну величину — ширину або висоту, браузер
          автоматично обчислить іншу для збереження пропорцій.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-abnf"
            spellcheck="false"
            data-highlighted="yes"
          >&lt;img
  src<span class="hljs-operator">=</span><span class="hljs-string">"https://images.pexels.com/photos/67112/pexels-photo-67112.jpeg"</span>
  alt<span class="hljs-operator">=</span><span class="hljs-string">"Macbook Air на сірому дерев'яному столі"</span>
  width<span class="hljs-operator">=</span><span class="hljs-string">"400"</span>
&gt;</pre>
        </div> -->
<!--Списки-->
<!-- <h3>Списки</h3>
        <p>
          Списки дозволяють упорядковувати колекції та представляти їх у
          наочному та зручному для користувача вигляді. Список — це контейнер,
          дітьми якого можуть бути лише елементи списку, теги
          <code>&lt;li&gt;</code> (list item).
        </p>
        <p><strong>Невпорядкований список</strong></p>
        <p>
          Тег <code>&lt;ul&gt;</code> (unordered list) створює маркований
          (невпорядкований) список, кожен елемент якого починається з невеликого
          символу (маркера). За допомогою CSS маркер можна буде забрати або
          замінити.
        </p>
        <p>
          Використовується для перерахування набору в довільному порядку.
          Наприклад, список курортів:
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-xml"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Найгарячіші курорти<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Цього року експерти радять відвідати наступні локації.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          
<span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Туніс<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Туреччина<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Греція<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Єгипет<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></pre>
        </div>
        <pre
          class="ql-blockquote"
          spellcheck="false"
        ><strong>Оформлення коду</strong> 
Зверни увагу, що вкладені елементи <code>&lt;li&gt;</code> розташовані не прямо під тегом <code>&lt;ul&gt;</code>, а з відступом. Стандартний відступ — 2 або 4 пробіли. Важливо, щоб відступ був однаковий для всього проєкту. Ця “ялинка” візуально відображає вкладеність елементів і покращує читабельність коду.</pre>
        <p><strong>Впорядкований список</strong></p>
        <p>
          Тег <code>&lt;ol&gt;</code> створює нумерований (впорядкований)
          список, тобто кожен елемент у списку пронумерований. Браузер нумерує
          елементи по порядку автоматично, і якщо видалити один або кілька
          елементів такого списку в коді, інші номери будуть автоматично
          пронумеровані.
        </p>
        <p>
          Найчастіше нумерований список використовується для перерахування дій,
          що мають виконуватися в певному порядку, наприклад, в рецепті.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-xml"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Як заварити чай<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Покрокова інструкція для чайників. Просто повтори і в тебе все вийде!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
          
<span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Закип'яти воду<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Засип чай у чашку<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Налий в чашку окропу<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>Зачекай 10 хвилин, після чого можна пити<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span></pre>
        </div>
        <pre class="ql-blockquote" spellcheck="false">
В теги&nbsp;<code>&lt;ul&gt;</code>&nbsp;і&nbsp;<code>&lt;ol&gt;</code> можна вкладати лише елементи списку, тобто теги&nbsp;<code>&lt;li&gt;</code>. 
При цьому всередині тегів <code>&lt;li&gt;</code> можуть бути вкладені деякі інші теги. Детальніше про вкладеність розглянемо в наступному розділі.</pre
        > -->
<!--Ієрархія заголовків-->
<!-- <h3><strong class="ql-size-large">Ієрархія заголовків</strong></h3>
        <p>
          Група тегів від <code>&lt;h1&gt;</code> до
          <code>&lt;h6&gt;</code> визначає текстові заголовки смислових розділів
          різного рівня. Вони вказують на важливість секції контенту
          розташованого після них. Це інструмент структурування текстового
          контенту.
        </p>
        <p>
          Тег <code>&lt;h1&gt;</code> найчастіше використовується лише один раз,
          як основний заголовок сторінки. Інші заголовки
          (<code>&lt;h2&gt;</code>, <code>&lt;h3&gt;</code>,
          <code>&lt;h4&gt;</code>, <code>&lt;h5&gt;</code>,
          <code>&lt;h6&gt;</code>) можуть використовуватися скільки завгодно
          разів, але їх завжди слід застосовувати правильно, дотримуючись
          ієрархії. На сторінці не обов’язково мають бути всі 6 рівнів
          заголовків. Зазвичай, достатньо перших трьох-чотирьох рівней.
        </p>
        <p>
          Пошукові системи звертають особливу увагу на заголовки, тому коректне
          використання цієї групи тегів є вкрай важливим. Не визначай рівень
          заголовка за розміром тексту на макеті. Не весь великий текст - це
          заголовки. Заголовком є вираз, що описує зміст розділу чи секції.
        </p> -->
<!--Семантика-->
<!-- <h3><strong class="ql-size-large">Семантика</strong></h3>
        <p><strong>Семантична розмітка</strong></p>
        <p>
          Семантична розмітка — підхід до створення HTML-розмітки, у якому вибір
          тегу залежить від:
        </p>
        <ul>
          <li>призначення тегу, вказаного в специфікації;</li>
          <li>типу контенту.</li>
        </ul>
        <p><strong>В чому переваги семантичної розмітки?</strong></p>
        <p>Семантична розмітка надважлива при створенні сайту.</p>
        <ul>
          <li><strong>Для просування сайту у пошукових системах.</strong></li>
        </ul>
        <p>
          Наявність семантичної розмітки сторінок допомагає пошуковим роботам
          краще розуміти, що знаходиться на сторінці, і в залежності від цього
          ранжувати сайти в пошуковій видачі.
        </p>
        <ul>
          <li><strong>Для коректної роботи асистивних технологій</strong></li>
        </ul>
        <p>
          Для користувачів з вадами зору основним інструментом знайомства з
          контентом є скрінрідер, що зачитує вміст сторінки. Семантична розмітка
          допомагає скрінрідеру коректно визначати який блок треба озвучити, а
          користувачу краще розуміти вміст.
        </p>
        <ul>
          <li><strong>Для кращої читабельності коду</strong></li>
        </ul>
        <p>
          Для інших розробників в команді та для тебе самого через декілька
          місяців чи літ важливо швидко розуміти структуру коду. Семантична
          розмітка — один із шляхів цього досягти.
        </p> -->
<!--Оформлення коду: теги-->
<!-- <h3><strong class="ql-size-large">Оформлення коду: теги</strong></h3>
        <p>
          У процесі створення веб-сайтів завжди необхідно повертатися до вже
          написаного коду для внесення змін. Зазвичай над проєктом працюють
          кілька розробників, а не один. Якщо код не оформлений відповідно до
          стандартів, він втрачає читабельність і, як наслідок, швидкість
          розробки падає.
        </p>
        <p>Давай підсумуємо, що ти маєш знати станом на цей час.</p>
        <ul>
          <li>Розміщуй кожен новий тег з нового рядка.</li>
          <li>
            Якщо контент займає менше одного рядка, відкриваючий та закриваючий
            теги мають бути розташовані у тому ж рядку безпосередньо до та після
            контенту.
          </li>
          <li>
            Якщо контент тегу займає <strong>кілька рядків</strong>,
            відкриваючий та закриваючий теги мають бути розташовані один під
            одним.
          </li>
          <li>
            Декілька атрибутів розділяються пробілом. Між атрибутом та його
            значенням є тільки знак <code>=</code>, а значення атрибута
            міститься у подвійних лапках.
          </li>
          <li>
            Вкладені елементи <code>&lt;li&gt;</code> розташовуються не прямо
            під тегом <code>&lt;ul&gt;</code>, а з відступом, що дорівнює 2 або
            4 пробілам. Відступ має бути однаковий для всього проєкта.
          </li>
        </ul>
      </div> -->
<!--Посилання-->
<!-- <h2>Посилання</h2> -->
<!--Блокові та рядкові елементи-->
<!-- <div>
        <h3>
          <strong class="ql-size-large">Блокові та рядкові елементи</strong>
        </h3>
        <p>
          <strong>Потік документа</strong> - це вертикальний та горизонтальний
          порядок відображення елементів на веб-сторінці.
        </p>
        <ul>
          <li>
            Вертикально потік іде зверху вниз, і за замовчуванням елементи
            відображаються на сторінці в тому порядку, в якому вони вказані в
            HTML-документі.
          </li>
          <li>
            Горизонтально потік йде зліва направо (або справа наліво для східних
            країн).
          </li>
        </ul>
        <p>
          Всі HTML елементи - це прямокутні області, що певним чином
          відображаються браузером на веб-сторінці. Є два основних типи
          елементів: блокові елементи (займають всю доступну ширину, як назва
          твору в зошиті) та рядкові (групуються один за одним, як слова в
          реченні).
        </p>
        <p>
          <strong>Блоковий елемент (block-level element) </strong>займає весь
          рядок цілком незалежно від обсягу його контенту, тому кілька блокових
          елементів візуально йдуть один за одним зверху вниз.
        </p>
        <p>Вони будуть відображатися один під одним.</p>
        <img
          src="./images/modul_1/Block-level-elements.jpg"
          alt="Блокові елементи"
        />
        <p>
          <strong>Рядковий елемент</strong> - займає те саме місце, що займає
          його контент. Отже, кілька рядкових елементів можуть розташовуватися в
          одному рядку. Коли в рядку не вистачає місця для вміщення такого
          елементу, він переноситься на новий рядок.
        </p>
        <img
          src="./images/modul_1/Inline-elements.jpg"
          alt="Рядковий елемент"
        /> -->
<!--Список посилань-->
<!-- <h3><strong class="ql-size-large">Список посилань</strong></h3>
        <p>
          В елемент списку, крім тексту, можуть бути вкладені інші теги.
          Наприклад, посилання з текстом. Зверни увагу, що в структурі тегу
          списку нічого не змінюється. Весь тег <code>&lt;a&gt;</code> стає
          контентом для елементу списку <code>&lt;li&gt;</code>.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-xml"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://rabota.ua/"</span>&gt;</span>Посилання 1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"https://jobs.dou.ua/"</span>&gt;</span>Посилання 2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></pre>
        </div>
        <p>
          Використання списку як контейнера для набору однотипного контенту:
        </p>
        <ul>
          <li>підвищує читабельність коду для розробників;</li>
          <li>
            оптимізує веб-сторінку для пошукових систем, наприклад, Google;
          </li>
          <li>
            покращує підтримку асистивних технологій для людей з обмеженими
            можливостями.
          </li>
        </ul> -->
<!--Вкладеність тегів. Зображення-посилання-->
<!-- <h3>
          <strong class="ql-size-large"
            >Вкладеність тегів. Зображення-посилання</strong
          >
        </h3>
        <p>
          Для створення зображення-посилання вкладаємо тег
          <code>&lt;img&gt;</code> всередину посилання
          <code>&lt;a&gt;</code> (замість текстового контенту) та обов’язково
          додаємо атрибут <code>alt</code> у тег зображення для завантаження
          текстового опису у разі проблем з картинкою.
        </p>
        <p>
          Використання <code>alt</code> також важливе для коректної роботи
          асистивних технологій та підвищення рейтингу пошуку Google.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-abnf"
            spellcheck="false"
            data-highlighted="yes"
          >&lt;a href<span class="hljs-operator">=</span><span class="hljs-string">"https://www.pexels.com/photo/animals-sweet-cat-kitty-57416/"</span>&gt;
  &lt;img
    src<span class="hljs-operator">=</span><span class="hljs-string">"https://images.pexels.com/photos/57416/cat-sweet-kitty-animals-57416.jpeg?w=640"</span>
    alt<span class="hljs-operator">=</span><span class="hljs-string">"Рудий кіт"</span>
    width<span class="hljs-operator">=</span><span class="hljs-string">"640"</span>
  &gt;
&lt;/a&gt;</pre>
        </div> -->
<!--Зображення-посилання в списку-->
<!-- <h3>
          <strong class="ql-size-large">Зображення-посилання в списку</strong>
        </h3>
        <p>
          <strong>Чи можливо поєднати список, посилання та зображення?</strong>
        </p>
        <p>
          Так, у тегах списку <code>&lt;ul&gt;</code> або
          <code>&lt;ol&gt;</code> є обов’язкові вкладені елементи
          <code>&lt;li&gt;</code> - це перший рівень вкладеності. У
          <code>&lt;li&gt;</code> можна вкласти посилання
          <code>&lt;а&gt;</code> - це вже другий рівень. А в тег посилання
          <code>&lt;а&gt;</code> можна вкласти <code>&lt;img&gt;</code> - це
          третій рівень вкладеності.
        </p>
        <p>У коді це виглядає так:</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-xml"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">""</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">""</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">""</span>&gt;</span>
      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">""</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>/&gt;</span>
    <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></pre>
        </div> -->
<!--Вкладеність тегів. Основи.-->
<!-- <h3>
          <strong class="ql-size-large">Вкладеність тегів. Основи.</strong>
        </h3>
        <p>
          Дотримуючись деяких правил, теги можна вкладати один в один. При
          вкладенні слід дотримуватися порядку їх закриття за принципом мотрійки
          (дивись приклад нижче).
        </p> -->
<!--Тег address-->
<!-- <h3><strong class="ql-size-large">Тег address</strong></h3>
        <p>
          Абсолютна більшість веб-сторінок містить контактну інформацію. Це
          можуть бути контакти організації або людини (автора статті або
          веб-сторінки загалом). В обох випадках доцільно використовувати тег
          <code>&lt;address&gt;</code> . Цей блоковий тег підтримує асистивні
          технології та покращує пошуковий рейтинг сторінки. Отже, користувачі,
          які будуть шукати за ключовими словами, наприклад «Компанія X контакти
          та адреса», отримають результат швидше.
        </p>
        <p>Контактна інформація може бути в будь-якій формі:</p>
        <ul>
          <li>фізична адреса;</li>
          <li>адреса електронної пошти;</li>
          <li>посилання на сайт;</li>
          <li>номер телефону, тощо.</li>
        </ul>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-xml"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-comment">&lt;!-- Приклад 1 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span>
mango@mail.pig
(111) 222-33-44
м. Київ,
Бульвар Лесі Українки, буд. 26,
4й поверх офіс 427
<span class="hljs-tag">&lt;/<span class="hljs-name">address</span>&gt;</span></pre>
        </div>
        <p>
          У <strong>прикладі 1</strong> на веб-сторінці вся контактна інформація
          буде в один рядок.
        </p>
        <p>
          Користувачу легше сприймати текст, розбитий на окремі рядки. Для
          розмітки масиву тексту з примусовими перенесеннями рядків для
          візуального форматування використовується тег
          <code>&lt;br /&gt;</code>.
        </p>
        <p>
          Подивись <strong>приклад 2</strong>, де розмітка одного рядка адреси
          поділена на декілька рядків.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-xml"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-comment">&lt;!-- Приклад 2 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span>
mango@mail.pig <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
(111) 222-33-44 <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> 
г. Київ, <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
Бульвар Лесі Українки, буд. 26, <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
4й поверх офіс 427
<span class="hljs-tag">&lt;/<span class="hljs-name">address</span>&gt;</span></pre>
        </div> -->
<!--Посилання: значення атрибуту href tel та mailto-->
<!-- <h3>
          <strong class="ql-size-large">Посилання: значення атрибуту </strong
          ><code class="ql-size-large"><strong>href</strong></code
          ><strong class="ql-size-large"> </strong
          ><code class="ql-size-large"><strong>tel</strong></code
          ><strong class="ql-size-large"> та </strong
          ><code class="ql-size-large"><strong>mailto</strong></code>
        </h3>
        <p>
          При натисканні на посилання можна не тільки переходити на інші
          сторінки, але й здійснювати дзвінки та надсилати поштові повідомлення.
          Для цього використовуються спеціальні значення атрибуту
          <code>href</code>.
        </p>
        <p>
          Щоб при натисканні на посилання користувачеві мобільного телефону було
          запропоновано здійснити дзвінок, треба додати в атрибут
          <code>href</code> значення <code>tel:номер-телефону</code>. Номер
          телефону в атрибуті має бути в міжнародному форматі (починається з +)
          та без будь-яких розділових знаків або пробілів.
        </p>
        <pre
          class="ql-syntax hljs language-subunit"
          spellcheck="false"
          data-highlighted="yes"
        >&lt;a href="tel:<span class="hljs-string">+14251234563</span>"&gt;<span class="hljs-string">+1</span>(425) 123<span class="hljs-string">-45</span><span class="hljs-string">-63</span>&lt;/a&gt;</pre>
        <p>
          Щоб при натисканні на посилання користувачеві мобільного телефону було
          запропоновано здійснити дзвінок, треба додати в атрибут
          <code>href</code> значення <code>tel:номер-телефону</code>. Номер
          телефону в атрибуті має бути в міжнародному форматі (починається з +)
          та без будь-яких розділових знаків або пробілів.
        </p>
        <p>
          Щоб при натисканні на посилання користувачеві відкривався його
          поштовий клієнт із заповненим полем одержувача, треба додати в атрибут
          <code>href</code> значення <code>mailto:адреса-пошти</code>, де
          <code>адреса-пошти</code> - це адреса одержувача, людини або компанії,
          що додається до приставки <code>mailto</code> без будь-яких символів
          або пробілів.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-xml"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"mailto:example@mail.pig"</span>&gt;</span>example@mail.pig<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></pre>
        </div>
        <p>
          Такі посилання можна вкладати в тег
          <code style="background-color: rgba(135, 131, 120, 0.15)"
            >&lt;address&gt;</code
          >
          та використовувати в поєднанні з розміткою контактної
          інформації.&nbsp;
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-xml"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"mailto:mango@mail.pig"</span>&gt;</span>mango@mail.pig<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"tel:+11112223344"</span>&gt;</span>+1(111) 222-33-44<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
м. Київ, <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
Бульвар Лесі Українки, буд. 26, <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span>
4й поверх офіс 427
<span class="hljs-tag">&lt;/<span class="hljs-name">address</span>&gt;</span></pre>
        </div> -->
<!--Посилання: атрибут download-->
<!-- <h3>
          <strong class="ql-size-large">Посилання: атрибут </strong
          ><code class="ql-size-large"><strong>download</strong></code>
        </h3>
        <p>
          У посиланні
          <code>&lt;a&gt;</code> значення атрибуту <code>href</code>
          може вказувати на шлях до файлу, як у прикладі нижче. У цьому випадку
          браузер спробує відкрити його на поточній вкладці, якщо вміє обробляти
          файли цього типу. Зазвичай так відбувається із зображеннями та
          PDF-файлами.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-xml"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/шлях/до/cv.pdf"</span>&gt;</span>Резюме<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></pre>
        </div>
        <p>
          Атрибут <code>download</code> повідомляє браузеру, що зазначений
          ресурс має бути не відкритий, а завантажений у разі, якщо користувач
          натисне на посилання.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-xml"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"/шлях/до/cv.pdf"</span> <span class="hljs-attr">download</span>&gt;</span>Завантажити резюме<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></pre>
        </div>
        <p>
          В атрибуті <code>download</code> можна не вказувати жодного значення.
          У цьому випадку ім’я файлу при завантаженні буде співпадати з
          ім’ям,вказаним в атрибуті <code>href</code> .
        </p>
        <p>
          Значення атрибуту <code>download</code> визначає нове ім'я файлу після
          його завантаження. Обмежень на допустимі значення немає: браузер
          автоматично визначить правильне розширення файлу та додасть його до
          завантаженого файлу — .img, .pdf, .txt, .html тощо.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-abnf"
            spellcheck="false"
            data-highlighted="yes"
          >&lt;a href<span class="hljs-operator">=</span><span class="hljs-string">"/шлях/до/cv.pdf"</span> download<span class="hljs-operator">=</span><span class="hljs-string">"cat-resume"</span>&gt;Завантажити резюме&lt;/a&gt;</pre>
        </div> -->
<!--Тег <button>-->
<!-- <h3><strong class="ql-size-large">Тег &lt;button&gt;</strong></h3>
        <p>
          Тег <code>&lt;button&gt;</code> створює клікабельну кнопку –
          інтерактивний елемент, який стає повністю функціональним за допомогою
          мови програмування JavaScript.
        </p>
        <p>
          <strong>Значення атрибута </strong><code><strong>type</strong></code>
        </p>
        <p>Атрибут <code>type</code> задає тип кнопки.</p>
        <ul>
          <li>
            значення атрибута за замовчуванням — <code>type="submit"</code>,
            оскільки кнопки створювалися для форм.
          </li>
          <li>
            при використанні кнопки поза формою, тобто як незалежний
            інтерактивний елемент, потрібно вказати значення атрибута
            <code>type="button"</code>.
          </li>
        </ul>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-xml"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"button"</span>&gt;</span>Open sidebar<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></pre>
        </div>
        <p><strong>Кнопка чи посилання?</strong></p>
        <p>
          Важливо не плутати посилання та кнопку, тому що в макеті сайту вони
          можуть виглядати однаково. CSS дозволяє ідентично стилізувати ці два
          елементи.
        </p>
        <img
          src="./images/modul_1/b03s16.png"
          alt="Is this a button or a link?"
        />
        <p>
          Використовуй <strong>посилання</strong>, якщо при кліку по елементу
          інтерфейсу відбувається:
        </p>
        <ul>
          <li>перехід за якоюсь адресою;</li>
          <li>скрол поточної сторінки;</li>
          <li>завантажується файл.</li>
        </ul>
        <p>Всі ці дії вимагають задати атрибут <code>href</code>.</p>
        <p>
          Використовуй <strong>кнопку</strong>, якщо при кліку відбувається щось
          без перезавантаження чи перенаправлення сторінки.
        </p>
        <pre class="ql-blockquote" spellcheck="false">
Найчастіше ми інтуїтивно розуміємо, що саме слід обрати. Проте, у складніших інтерфейсах при постановці завдання розробнику вказується необхідний тип елемента.</pre
        >
      </div> -->
<!--Структурна розмітка-->
<!-- <h2>Структурна розмітка</h2>
      <div></div> -->

<!--<h2>Скелет HTML-документа</h2>
      <div></div>

      <h2>Алгоритм створення сторінки</h2>
      <div></div>

      <h2>Матеріали</h2>
      <div></div>

      <h2>Уроки</h2>
      <div></div>

      <h2>Домашнє завдання</h2>
      <div></div> -->
<!-- </section> -->
<!--Модуль 2. Вступ до CSS-->
<!-- <h1>Модуль 2. Вступ до CSS</h1>
    <section>
      <h2>Програма модуля</h2>
      <h2>Підключення стилів</h2>
      <h2>Колір</h2>
      <h2>Селектори</h2>
      <h2>Каскад стилів</h2>
      <h2>Шрифт</h2>
      <h2>Оформлення тексту</h2>
      <h2>Глобальні стилі. Нормалізація.</h2>
      <h2>План виконання ДЗ 2</h2>
      <h2>Уроки</h2>
      <h2>Домашнє завдання</h2>
    </section> -->
<!--Модуль 3. Блокова модель. Flexbox-->
<!-- <h1>Модуль 3. Блокова модель. Flexbox</h1>
    <section>
      <h2>Програма модулю</h2>
      <h2>Блокова модель елемента</h2>
      <h2>Геометрія елемента</h2>
      <h2>Типи елементів</h2>
      <h2>Зображення</h2>
      <h2>Flexbox</h2>
      <h2>Властивості контейнера</h2>
      <h2>Властивості елементів</h2>
      <h2>Структурні псевдокласи</h2>
      <h2>План виконання ДЗ 3</h2>
      <h2>Домашнє завдання</h2>
    </section> -->
<!--Модуль 4. Декоративні ефекти-->
<!-- <h1>Модуль 4. Декоративні ефекти</h1>
    <section> -->
<!--Фон елемента-->
<!-- <h2>Фон елемента</h2>
      <div>
        <p>
          <strong class="ql-size-large"
            >Контентні та декоративні зображення</strong
          >
        </p>
        <p>
          На сайті завжди є зображення. Вони допомагають виразити вміст сторінки
          чи просто додають декоративне оформлення. Отже, є два типи зображень:
        </p>
        <ol>
          <li>контентні;</li>
          <li>декоративні.</li>
        </ol>
        <p>
          <strong
            >Яка різниця між контентними та декоративними зображеннями?</strong
          >
        </p>
        <p>
          <strong>Контентні зображення</strong> несуть смислове навантаження,
          відносяться до вмісту сторінки та допомагають донести до користувача
          корисну інформацію. Вони додаються в HTML-розмітці за допомогою тега
          <code>&lt;img&gt;</code> з обов'язково заповненим атрибутом
          <code>alt</code>, що описує зображення.
        </p>
        <pre
          class="ql-blockquote"
          spellcheck="false"
        ><strong>Приклади контентних зображень:</strong> — фотографія продукту на картці товару в інтернет-магазині; — фотографії членів команди; — логотип компанії; — рекламні банери; — карти з локацією; — картинки слайдера.</pre>
        <p>
          <strong>Декоративні зображення</strong> використовуються для
          додаткового оформлення. Вони не несуть корисної інформації та є
          елементами дизайну. Додаються через CSS як фон елемента або, у випадку
          векторної графіки, розмічаються в HTML тегом <code>&lt;svg&gt;</code>.
        </p>
        <pre
          class="ql-blockquote"
          spellcheck="false"
        ><strong>Приклади декоративних зображень:</strong> - кастомні маркери списків; - допоміжні іконки; - плашки; - фонові зображення блоків.</pre>
        <p>
          <strong>Фон</strong> — це не тільки декоративний ефект для оформлення,
          але й допомога у сприйнятті ідеї, підказка про вміст елемента.
          Наприклад, зелений колір асоціюється з успішною операцією, а червоний
          - з помилкою. Фонове зображення також допомагає передати вміст або
          додати оформлення.
        </p>
        <p>
          <strong class="ql-size-large"
            >Властивість <code>background-image</code></strong
          >
        </p>
        <p>
          Властивість <code>background-image</code> задає фонове зображення
          елемента, адреса якого вказується аргументом функції
          <code>url()</code>. Це може бути як відносний, так і абсолютний шлях.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">шлях до зображення</span>);</pre>
        </div>
        <pre
          class="ql-blockquote"
          spellcheck="false"
        >Елемент фону поширюється лише на область вмісту і падінг і <strong>ніколи на маржин</strong>, бо маржин є зовнішнім відступом.</pre>
        <p>
          Варто відразу задати колір фону та фонове зображення, яке завжди буде
          розташоване поверх фону. Наприклад, у випадку коли зображення не
          завантажилося, користувач побачить хоча б колір фону, що виділяється,
          а не порожнє місце. Це особливо актуально, якщо в блоці є текст, колір
          якого не контрастує з основним кольором документа.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-selector-class">.hero</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#2a2a2a</span>;
  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">шлях до зображення</span>);
}</pre>
        </div>
        <p>
          <strong class="ql-size-large"
            >Властивість <code>background-repeat</code></strong
          >
        </p>
        <p>
          Властивість <code>background-repeat</code> керує повторенням фонового
          зображення. За замовчуванням воно повторюється по горизонталі (X) та
          вертикалі (Y). Це відбувається, якщо зображення менше ніж розмір
          елемента.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-gml"
            spellcheck="false"
            data-highlighted="yes"
          >background-<span class="hljs-keyword">repeat</span>: <span class="hljs-keyword">repeat</span> | <span class="hljs-keyword">repeat</span>-<span class="hljs-variable language_">x</span> | <span class="hljs-keyword">repeat</span>-<span class="hljs-variable language_">y</span> | no-<span class="hljs-keyword">repeat</span></pre>
        </div>
        <ul>
          <li>
            <code>repeat</code> - повторювати X і Y. Значення за замовчуванням.
          </li>
          <li>
            <code>repeat-x</code> - повторювати тільки X, тобто по горизонталі.
          </li>
          <li>
            <code>repeat-y</code> - повторювати тільки Y, тобто по вертикалі.
          </li>
          <li><code>no-repeat</code> - не повторювати.</li>
        </ul>
        <p>
          Навіть якщо ви знаєте, що зображення більше ніж розміри елемента,
          хорошим тоном вважається задати властивість
          <code>background-repeat</code> зі значенням <code>no-repeat</code>,
          щоб унеможливити будь-яку можливість небажаної поведінки.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-selector-class">.hero</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#2a2a2a</span>;
  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">шлях до зображення</span>);
  <span class="hljs-attribute">background-repeat</span>: no-repeat;
}</pre>
        </div>
        <p>
          <strong class="ql-size-large"
            >Властивість <code>background-position</code></strong
          >
        </p>
        <p>
          Властивість <code>background-position</code> керує положенням фонового
          зображення відносно&nbsp;рамки елемента, використовуючи дві координати
          — <code>x</code> по горизонталі і <code>y</code> по вертикалі.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arduino"
            spellcheck="false"
            data-highlighted="yes"
          >
background-position: x y;</pre
          >
        </div>
        <p>
          У якості значення можна використовувати абсолютні (<code>px</code>) чи
          відносні (<code>%</code>) одиниці, і навіть ключові слова (top,
          bottom, right, left, center).
        </p>
        <p>
          За замовчуванням задане
          значення&nbsp;<code>left</code>&nbsp;для&nbsp;<code>x</code>&nbsp;і&nbsp;<code>top</code>&nbsp;для&nbsp;<code>y</code>,
          тобто фон позиціонується відносно&nbsp;верхнього лівого кута елемента.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arduino"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-comment">/* Розмістити фонове зображення по центру */</span>
  background-position: <span class="hljs-number">50</span>% <span class="hljs-number">50</span>%;
          
<span class="hljs-comment">/* Розмістити фонове зображення 100px від лівого краю та 200px від верху */</span>
  background-position: <span class="hljs-number">100</span>px <span class="hljs-number">200</span>px;
          
<span class="hljs-comment">/* Розмістити фонове зображення у нижній правий кут */</span>
  background-position: right bottom;
          
<span class="hljs-comment">/* Розмістити фонове зображення у верхній лівий кут */</span>
  background-position: left top;</pre>
        </div>
        <p>
          <strong class="ql-size-large"
            >Налаштування позиції зі зміщенням</strong
          >
        </p>
        <p>
          Щоб не прив'язуватися до розмірів елемента та не задавати позицію фону
          жорстко, можна використовувати синтаксис позиції зі зміщенням.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-gml"
            spellcheck="false"
            data-highlighted="yes"
          >background-position: <span class="hljs-variable language_">x</span> зміщення-<span class="hljs-variable language_">x</span> <span class="hljs-variable language_">y</span> зміщення-<span class="hljs-variable language_">y</span></pre>
        </div>
        <p>
          Наприклад, якщо необхідно розташувати фон у нижньому правому куті
          елемента довільних розмірів таким чином, щоб фон відставав від меж на
          <code>30px</code> справа і <code>20px</code> знизу.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-apache"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-attribute">background</span>-position: right <span class="hljs-number">30</span>px bottom <span class="hljs-number">20</span>px;</pre>
        </div>
        <p>
          <strong class="ql-size-large"
            >Властивість <code>background-size</code></strong
          >
        </p>
        <p>
          За замовчуванням браузер не змінює розмір фонового зображення. Якщо
          картинка буде більшою або меншою за розмір елемента, утвориться
          порожній простір, не зайнятий фоном, або, навпаки, фон буде видно лише
          частково.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arduino"
            spellcheck="false"
            data-highlighted="yes"
          >background-size: <span class="hljs-keyword">auto</span> | значення | cover | contain</pre>
        </div>
        <p>
          Ця властивість дозволяє коригувати розміри зображення шляхом
          налаштування необхідної ширини та висоти. Якщо не вказати висоту, вона
          буде розрахована автоматично зі збереженням пропорцій.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arduino"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-comment">/* Вихідні розміри зображення, значення за замовчуванням */</span>
   background-size: <span class="hljs-keyword">auto</span> <span class="hljs-keyword">auto</span>;
          
<span class="hljs-comment">/* Ширина 200px, висота буде пропорційна */</span>
   background-size: <span class="hljs-number">200</span>px;
          
<span class="hljs-comment">/* Ширина 200px, висота 300px */</span>
   background-size: <span class="hljs-number">200</span>px <span class="hljs-number">300</span>px;</pre>
        </div>
        <p>
          Значенням також можуть бути два зарезервовані слова:&nbsp;<code
            >cover</code
          >
          і <code>contain</code>. Функція обох значень — максимально вмістити у
          контейнер фонове зображення, але різними способами.
        </p>
        <ul>
          <li><code>cover</code> — за рахунок обрізання зайвого.</li>
          <li>
            <code>contain</code>&nbsp;— за рахунок утворення порожнього простору
            в контейнері.
          </li>
        </ul>
        <img src="./images/modul_4/04-1-size.png" alt="background-size" />
        <p>
          <strong>Значення&nbsp;</strong><code><strong>cover</strong></code
          ><strong>:</strong>
        </p>
        <ul>
          <li>Гарантовано зберігає пропорції зображення.</li>
          <li>
            Зображенню задані <strong>мінімальні розміри</strong>, за яких воно
            <strong>заповнить фон</strong> <strong>всього елемента</strong>.
          </li>
          <li>
            Якщо пропорції зображення та елемента різні,
            <strong>частина зображення</strong> по вертикалі або горизонталі
            <strong>візуально обрізається</strong>.
          </li>
        </ul>
        <p><strong>Значення</strong>&nbsp;<code>contain</code>:</p>
        <ul>
          <li>Гарантовано зберігає пропорції зображення.</li>
          <li>
            Зображенню задані <strong>максимально можливі розміри</strong>, за
            яких воно <strong>повністю поміщається в елемент</strong>.
          </li>
          <li>
            Зображення <strong>може не закрити весь фон</strong> елемента по
            вертикалі або горизонталі, якщо пропорції блоку та зображення не
            збігаються.
          </li>
        </ul>
        <p>
          Додамо властивість <code>background-size</code> із значенням
          <code>cover</code> для елемента секції привітання.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-selector-class">.hero</span> {
  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#2a2a2a</span>;
  <span class="hljs-attribute">background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">шлях до зображення</span>);
  <span class="hljs-attribute">background-repeat</span>: no-repeat;
  <span class="hljs-attribute">background-position</span>: center;
  <span class="hljs-attribute">background-size</span>: cover;
}</pre>
        </div>
        <p><strong class="ql-size-large">Багатошаровий фон</strong></p>
        <p>
          Елементу можна задати кілька фонових зображень одночасно. Достатньо
          перерахувати їх у властивості&nbsp;<code>background-image</code> через
          кому. Для кожного зображення також можна задати значення інших
          властивостей фону, також через кому в кожній властивості.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-attribute">  background-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">шлях до зображення 1</span>), <span class="hljs-built_in">url</span>(<span class="hljs-string">шлях до зображення 2</span>);
  <span class="hljs-attribute">background-size</span>: <span class="hljs-number">100px</span>, cover;
  <span class="hljs-attribute">background-position</span>: top right, center;
  <span class="hljs-attribute">background-repeat</span>: repeat-x, no-repeat;</pre>
        </div>
        <pre class="ql-blockquote" spellcheck="false"><strong>Порада</strong> 
          У більшості випадків багатошаровий фон можна замінити одним зображенням, на якому в спеціальному редакторі були поєднані всі інші. Вага такого файлу буде меншою, ніж загальна вага окремих картинок, і браузеру необхідно буде зробити лише один запит замість п'яти, що також збільшить швидкість завантаження та відображення сторінки.</pre>

        <p><strong class="ql-size-large">Лінійний градієнт</strong></p>
        <p>
          Градієнт - перехід від одного кольору до іншого. У CSS градієнт - це
          фонове зображення, тому він задається як значення властивості
          <code>background-image</code>. Лінійний градієнт створюється за
          допомогою двох і більше кольорів, яким задано напрямок розповсюдження.
        </p>
        <p>
          Формат значення кольору може бути будь-яким: ключові слова, rgb, rgba
          чи hex, та їх можна змішувати.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-xml"
            spellcheck="false"
            data-highlighted="yes"
          >background-image: linear-gradient(
  <span class="hljs-tag">&lt;<span class="hljs-name">напрямок</span>&gt;</span>, 
  <span class="hljs-tag">&lt;<span class="hljs-name">колір-1</span>&gt;</span>, 
  <span class="hljs-tag">&lt;<span class="hljs-name">колір-2</span>&gt;</span>, 
  <span class="hljs-tag">&lt;<span class="hljs-name">колір-3</span>&gt;</span>, 
  ...
)</pre>
        </div>
        <p>
          Напрямок градієнта задається ключовими словами <code>to top</code>,
          <code>to right</code>, <code>to bottom</code>, <code>to left</code> і
          їх комбінаціями. Якщо напрямок не вказано, використовується значення
          за замовчуванням - зверху-вниз (<code>to bottom</code>). У разі коли
          напрямок задано парою ключових слів, наприклад,
          <code>to top left</code>, початкова точка градієнта буде розташована в
          правому нижньому кутку, тобто протилежному.
        </p>
        <p>
          Напрямок також можна задати кутом нахилу в градусах - одиниця
          <code>deg</code>. Значення <code>0deg</code> є аналогічним
          <code>to top</code>. Збільшення кута повертає напрямок лінії
          градієнта. Лінія градієнта - це пряма, що проходить через центр блоку
          і вздовж якої розподіляються кольори за годинниковою стрілкою.
        </p>
        <img
          src="./images/modul_4/556ce455-691a-4cd6-9895-68967285872fgradient-direction.gif"
          alt="linear-gradient"
        />
        <pre class="ql-blockquote" spellcheck="false">
У цій анімації кут збільшується від 0 до 360 градусів із кроком 10 градусів. Низька роздільна здатність дозволяє краще бачити, як різні кольори відображаються у вигляді «ліній», що завжди перпендикулярні лінії градієнта.</pre
        >
        <p>
          <strong class="ql-size-large"
            >Властивість <code>background</code></strong
          >
        </p>
        <p>
          Властивість <code>background</code> - це складена властивість
          <span style="color: rgb(0, 0, 0)"
            >для одночасного встановлення значень всіх розглянутих
            властивостей.</span
          >
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-arduino"
            spellcheck="false"
            data-highlighted="yes"
          >
background: background-color background-image background-repeat background-position background-attachment background-size</pre
          >
        </div>
        <p>
          Якщо компонент не вказано, використовується його значення за
          замовчуванням.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-comment">/* Встановить лише колір фону */</span>
   <span class="hljs-attribute">background</span>: <span class="hljs-number">#2a2a2a</span>;
          
<span class="hljs-comment">/* Прозорий колір фону з картинкою, що повторюється по x, починаючи з верхнього лівого кута. */</span>
   <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">шлях до зображення</span>) repeat-x;</pre>
        </div>
        <pre class="ql-blockquote" spellcheck="false">
Рекомендується, як мінімум спочатку, використовувати окремі властивості для кожного значення, тому що зі складеною властивістю&nbsp;<code>background</code>&nbsp;можна легко заплутатися.</pre
        >
      </div> -->
<!--Тінь елемента-->
<!-- <h2>Тінь елемента</h2>
      <div>
        <p>
          <strong class="ql-size-large"
            >Властивість <code>box-shadow</code></strong
          >
        </p>
        <p>
          Тінь додає елементу ефект об'єму та висоту. Порівняй, як виглядає
          елемент без тіні та з тінню. Різниця помітна, чи не так?
        </p>
        <img src="./images/modul_4/shadow-intro.png" alt="box-shadow" />
        <p>
          Тіні бувають зовнішні та внутрішні, розмиті та плоскі, одинарні та
          багатошарові.
        </p>
        <p>
          Звісно, всі ці нюанси досконало знає дизайнер, який створює макет. Але
          розробник має точно перенести всі ефекти макета на сторінку. Отже, він
          також має розуміти, з чого складається тінь та як відтворити це в
          коді.
        </p>
        <p>
          Властивість&nbsp;<code>box-shadow</code>&nbsp;задає елементу одну або
          більше тіней. За замовчуванням розмір тіні збігається з розміром
          елемента, а її колір такий самий, як і колір його тексту.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-nix"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-params">box-shadow:</span> <span class="hljs-symbol">&lt;x-offset&gt;</span> <span class="hljs-symbol">&lt;y-offset&gt;</span> <span class="hljs-symbol">&lt;blur&gt;</span> <span class="hljs-symbol">&lt;spread&gt;</span> <span class="hljs-symbol">&lt;color&gt;</span></pre>
        </div>
        <ul>
          <li>
            <code>x-offset</code> — горизонтальне зміщення. Позитивне значення
            зміщує тінь праворуч від блоку, негативне – ліворуч. Обов'язкове
            значення.
          </li>
          <li>
            <code>y-offset</code> — вертикальне зміщення. Позитивне значення
            зміщує тінь вниз, негативне - вгору. Обов'язкове значення.
          </li>
          <li>
            <code>blur</code> — радіус розмиття. Чим більше значення, тим
            сильніше розмита тінь. Необов'язкове значення.
          </li>
          <li>
            <code>spread</code> — радіус поширення. Позитивне значення збільшує
            тінь, негативне — зменшує. Необов'язкове значення.
          </li>
          <li>
            <code>color</code> — колір тіні. Можна використовувати будь-який
            формат запису кольору. Необов'язкове значення.
          </li>
        </ul>
        <p><strong class="ql-size-large">Багатошарова тінь</strong></p>
        <p>
          На один елемент можна додати кілька тіней, вказавши їх значення через
          кому.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-nix"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-params">box-shadow:</span> <span class="hljs-symbol">&lt;x-offset&gt;</span> <span class="hljs-symbol">&lt;y-offset&gt;</span> <span class="hljs-symbol">&lt;blur&gt;</span> <span class="hljs-symbol">&lt;spread&gt;</span> <span class="hljs-symbol">&lt;color&gt;</span>,
            <span class="hljs-symbol">&lt;x-offset&gt;</span> <span class="hljs-symbol">&lt;y-offset&gt;</span> <span class="hljs-symbol">&lt;blur&gt;</span> <span class="hljs-symbol">&lt;spread&gt;</span> <span class="hljs-symbol">&lt;color&gt;</span>,
            <span class="hljs-symbol">&lt;x-offset&gt;</span> <span class="hljs-symbol">&lt;y-offset&gt;</span> <span class="hljs-symbol">&lt;blur&gt;</span> <span class="hljs-symbol">&lt;spread&gt;</span> <span class="hljs-symbol">&lt;color&gt;</span>,
            ...</pre>
        </div>
        <p>
          Виходить щось схоже на багатошаровий пиріг. Перша тінь у списку
          розміщується вгорі, остання — у самому низу. Тобто кожна попередня
          тінь зі списку розташовується на вищому шарі і візуально перекриває
          всі наступні.
        </p>
        <p>Цей підхід дозволяє зробити дуже м'які та красиві тіні.</p>
        <p><strong class="ql-size-large">Внутрішня тінь</strong></p>
        <p>
          Якщо зовнішня тінь візуально піднімає елемент, то внутрішня тінь
          дозволяє додати ефект глибини, візуально заглиблюючи елемент.
          Синтаксис оголошення внутрішньої тіні аналогічний синтаксису звичайної
          тіні, але першим значенням необхідно вказати <code>inset</code>.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-nix"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-params">box-shadow:</span> inset <span class="hljs-symbol">&lt;x-offset&gt;</span> <span class="hljs-symbol">&lt;y-offset&gt;</span> <span class="hljs-symbol">&lt;blur&gt;</span> <span class="hljs-symbol">&lt;spread&gt;</span> <span class="hljs-symbol">&lt;color&gt;</span></pre>
        </div>
      </div> -->
<!--Векторна графіка-->
<!-- <h2>Векторна графіка</h2>
      <div>
        <p>
          <strong>SVG (Scalable Vector Graphics)</strong> - формат графіки та
          мова для опису векторних зображень. Всередині файл не бінарний, а
          звичайний текст (XML), що описує об'єкти, їх ефекти та поведінку.
        </p>
        <img src="./images/modul_4/4-3-1.png" alt="Raster and vector" />
        <p>Векторна графіка має низку переваг.</p>
        <ul>
          <li>
            <strong>Масштабування</strong> — на відміну від растрової графіки,
            SVG не втрачає якості при масштабуванні.
          </li>
          <li>
            <strong>Розмір файла</strong> — векторні зображення важать набагато
            менше растрових, якщо використовуються для іконок або іншої
            абстрактної графіки. Використання вектора для фотореалістичних
            зображень навпаки веде до великого розміру файла.
          </li>
          <li>
            <strong>Динамічність</strong> — за допомогою CSS і JavaScript можна
            змінювати параметри векторного зображення, наприклад, колір або
            рамки.
          </li>
        </ul>
        <p>
          Векторну графіку, так само як і растрові зображення, можна додавати за
          допомогою елемента <code>img</code>. Достатньо вказати:
        </p>
        <ul>
          <li>шлях до зображення;</li>
          <li>текстовий опис;</li>
          <li>інші атрибути (за потреби).</li>
        </ul>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-abnf"
            spellcheck="false"
            data-highlighted="yes"
          >&lt;img src<span class="hljs-operator">=</span><span class="hljs-string">"path/to/image.svg"</span> alt<span class="hljs-operator">=</span><span class="hljs-string">"Description"</span> /&gt;</pre>
        </div>
        <p>
          Векторне зображення також може використовуватися як фон елемента у
          властивості <code>background-image</code>.
        </p>
        <p>
          З векторним фоном можна робити будь-які маніпуляції, так само, як і з
          зображеннями растрової графіки.
        </p>
        <p><strong class="ql-size-large">Вбудований SVG</strong></p>
        <p>
          Додавання векторних зображень за допомогою елемента
          <code>&lt;img&gt;</code> або як фону через
          <code>background-image</code> використовується для статичної графіки,
          наприклад, абстрактного фону або іконок, для яких не потрібно додавати
          ефект ховеру або фокусу.&nbsp;
        </p>
        <p>
          У цих методів є один істотний недолік: немає можливості динамічно
          змінити колір або інші характеристики векторного зображення з CSS.
        </p>
        <p>
          SVG-зображення можна додати повністю в HTML. Тобто відкрити SVG-файл у
          текстовому редакторі, скопіювати вміст і вставити його в
          HTML-документ. Це називається “<strong
            >вбудований SVG” (inline svg)</strong
          >.
        </p>
        <p>Проте цей підхід має низку обмежень.</p>
        <ul>
          <li>Вбудований SVG-код збільшує розмір файлу HTML.</li>
          <li>
            Неможливо повторно використовувати те саме зображення без дублювання
            коду.
          </li>
          <li>
            Підтримка та виправлення вбудованого SVG трудомісткі, доведеться
            шукати його в HTML коді.
          </li>
          <li>
            Браузер не може кешувати такі зображення, на відміну від зовнішніх
            файлів SVG.
          </li>
        </ul>

        <p>
          <strong class="ql-size-large">Властивість <code>fill</code></strong>
        </p>
        <p>
          У CSS можна динамічно змінювати деякі параметри вбудованого векторного
          зображення, наприклад, колір. Властивість <code>fill</code> керує
          кольором заливки. Колір можна задавати у будь-якому зручному форматі.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-comment">/* Встановлюємо колір заливки у спокійному стані. */</span>
  <span class="hljs-selector-class">.icon</span> {
    <span class="hljs-attribute">fill</span>: <span class="hljs-number">#2a2a2a</span>;
}
          
<span class="hljs-comment">/* Змінюємо колір заливки при ховері. */</span>
  <span class="hljs-selector-class">.icon</span><span class="hljs-selector-pseudo">:hover</span> {
    <span class="hljs-attribute">fill</span>: <span class="hljs-number">#03a9f4</span>;
}</pre>
        </div>
        <p>
          Якщо колір заливки не вказано, фігура буде залита поточним кольором
          тексту (за замовчуванням — чорним).
        </p>
        <p>
          Прибрати заливку можна значенням <code>none</code>, в результаті чого
          вийде повністю прозора фігура.
        </p>
        <p>
          В проєкті багато іконок і логотипів. Всім їм треба задавати окремі
          налаштування для різних станів. При цьому, треба й про роботу сторінки
          подумати, бо кожне звернення до сервера — це час. Чи існує готове
          рішення для цієї проблеми?
        </p>
        <p><strong class="ql-size-large">SVG-спрайту</strong></p>
        <p>
          SVG-спрайт — це техніка, яку застосовують у більшості випадків під час
          роботи з векторною графікою.
        </p>
        <ul>
          <li>Усі векторні іконки збираються до одного файлу.</li>
          <li>
            Файл спрайту кешується браузером і не буде завантажуватися&nbsp;при
            повторному відвідуванні.
          </li>
          <li>
            Іконкам із спрайту можна змінювати колір та інші характеристики
            через CSS.
          </li>
        </ul>
        <p><strong>Алгоритм створення SVG-спрайт</strong></p>
        <ol>
          <li>
            Відкрий макет у Figma, обери там всі іконки й експортуй їх в
            SVG-форматі на свій комп’ютер.
          </li>
          <li>
            Зайди на
            <a
              href="https://icomoon.io/app/"
              rel="noopener noreferrer"
              target="_blank"
              >icomoon.io</a
            >
            , натисни кнопку <strong>Import Icons</strong> зверху ліворуч та
            додай всі іконки.
          </li>
          <li>
            Натисни <strong>Generate SVG &amp; More</strong> внизу ліворуч.
          </li>
          <li>Натиснути <strong>Download</strong> внизу ліворуч.</li>
        </ol>
        <p>
          <strong>SVG-документ</strong> - це просто текстовий файл, в якому: на
          відміну від растрової графіки, описані фігури, які відтворюватиме
          браузер. В одному файлі можна описати безліч різних груп фігур,
          використовуючи елемент <code>&lt;symbol&gt;</code>, після чого,
          задавши кожному символу унікальний <code>id</code>, звернутися до
          будь-якого з них з HTML-документа.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-dns"
            spellcheck="false"
            data-highlighted="yes"
          >&lt;svg aria-hidden="true" style="position:absolute<span class="hljs-comment">;width:0;height:0" xmlns="&lt;http://www.w3.org/2000/svg&gt;" overflow="hidden"&gt;</span>
  &lt;defs&gt;
    &lt;!-- Trash can icon --&gt;
    &lt;symbol id="delete" viewBox="<span class="hljs-number">0 0 32 32</span>"&gt;
      &lt;path d="M8 <span class="hljs-number">25.333C8</span> <span class="hljs-number">26.8 9.2</span> <span class="hljs-number">28 10.667</span> <span class="hljs-number">28h</span><span class="hljs-number">10.667c1</span>.<span class="hljs-number">467 0 2</span>.<span class="hljs-number">667-1.2</span> <span class="hljs-number">2.667-2</span>.<span class="hljs-number">667</span>v-<span class="hljs-number">16h</span>-<span class="hljs-number">16</span>v16zm17.<span class="hljs-number">333</span>-<span class="hljs-number">20h</span>-<span class="hljs-number">4.667L19</span>.<span class="hljs-number">333</span> <span class="hljs-number">4h</span>-<span class="hljs-number">6</span>.<span class="hljs-number">667</span>l-<span class="hljs-number">1.333 1</span>.<span class="hljs-number">333</span>H6.<span class="hljs-number">666V8h18</span>.<span class="hljs-number">667</span>V5.<span class="hljs-number">333</span>z" /&gt;
    &lt;/symbol&gt;
    &lt;!-- Camera icon --&gt;
    &lt;symbol id="camera" viewBox="<span class="hljs-number">0 0 32 32</span>"&gt;
      &lt;path d="M20.<span class="hljs-number">267 16a4</span>.<span class="hljs-number">267</span> <span class="hljs-number">4.267 0</span> <span class="hljs-number">11-8.534</span> <span class="hljs-number">0 4.267</span> <span class="hljs-number">4.267 0</span> <span class="hljs-number">018.534</span> <span class="hljs-number">0</span>z" /&gt;
      &lt;path d="M12 <span class="hljs-number">2.667L9</span>.<span class="hljs-number">56</span> <span class="hljs-number">5.334H5</span>.<span class="hljs-number">333</span>a<span class="hljs-number">2.675 2</span>.<span class="hljs-number">675 0 00</span>-<span class="hljs-number">2.667 2</span>.<span class="hljs-number">667v16c0</span> <span class="hljs-number">1.467 1</span>.<span class="hljs-number">2 2.667</span> <span class="hljs-number">2.667 2</span>.<span class="hljs-number">667h</span><span class="hljs-number">21.333c1</span>.<span class="hljs-number">467 0 2</span>.<span class="hljs-number">667-1.2</span> <span class="hljs-number">2.667-2</span>.<span class="hljs-number">667</span>v-<span class="hljs-number">16</span>c<span class="hljs-number">0-1.467</span>-<span class="hljs-number">1</span>.<span class="hljs-number">2-2.667</span>-<span class="hljs-number">2.667-2</span>.<span class="hljs-number">667h</span>-<span class="hljs-number">4</span>.<span class="hljs-number">227</span>l-<span class="hljs-number">2</span>.<span class="hljs-number">44</span>-<span class="hljs-number">2</span>.<span class="hljs-number">667h</span>-<span class="hljs-number">8</span>zm4 <span class="hljs-number">20</span>c-<span class="hljs-number">3.68 0-6</span>.<span class="hljs-number">667</span>-<span class="hljs-number">2.987-6</span>.<span class="hljs-number">667</span>-<span class="hljs-number">6.667S12</span>.<span class="hljs-number">32 9.333</span> <span class="hljs-number">16 9.333</span> <span class="hljs-number">22.667 12</span>.<span class="hljs-number">32 22.667</span> <span class="hljs-number">16 19.68 22</span>.<span class="hljs-number">667 16 22</span>.<span class="hljs-number">667</span>z" /&gt;
    &lt;/symbol&gt;
    &lt;!-- Portfolio icon --&gt;
    &lt;symbol id="work" viewBox="<span class="hljs-number">0 0 32 32</span>"&gt;
      &lt;path d="M26.<span class="hljs-number">667</span> <span class="hljs-number">8h</span>-<span class="hljs-number">5.333V5</span>.<span class="hljs-number">333</span>a<span class="hljs-number">2.658 2</span>.<span class="hljs-number">658 0 00</span>-<span class="hljs-number">2.667-2</span>.<span class="hljs-number">667h</span>-<span class="hljs-number">5.333a2</span>.<span class="hljs-number">658</span> <span class="hljs-number">2.658 0</span> <span class="hljs-number">00-2.667</span> <span class="hljs-number">2</span>.<span class="hljs-number">667V8H5</span>.<span class="hljs-number">334</span>a<span class="hljs-number">2.646 2</span>.<span class="hljs-number">646 0 00</span>-<span class="hljs-number">2.653 2</span>.<span class="hljs-number">667</span>l-.<span class="hljs-number">013</span> <span class="hljs-number">14.667a2</span>.<span class="hljs-number">658</span> <span class="hljs-number">2.658 0</span> <span class="hljs-number">002.667</span> <span class="hljs-number">2.667h21</span>.<span class="hljs-number">333</span>a<span class="hljs-number">2.658 2</span>.<span class="hljs-number">658</span> <span class="hljs-number">0</span> <span class="hljs-number">002.667</span>-<span class="hljs-number">2.667V10</span>.<span class="hljs-number">667</span><span class="hljs-keyword">A</span><span class="hljs-number">2.658 2</span>.<span class="hljs-number">658</span> <span class="hljs-number">0</span> <span class="hljs-number">0026.668</span> <span class="hljs-number">8</span>zm-<span class="hljs-number">8</span> <span class="hljs-number">0h</span>-<span class="hljs-number">5.333V5</span>.<span class="hljs-number">333h</span>5.<span class="hljs-number">333</span>V8z" /&gt;
    &lt;/symbol&gt;
  &lt;/defs&gt;
&lt;/svg&gt;</pre>
        </div>
        <p>
          Отже, всередині SVG-спрайту є набір елементів
          <code>&lt;svg&gt;</code> і <code>&lt;symbol&gt;</code>, що описують
          весь SVG-спрайт цілком і кожну фігуру окремо. Кожному
          <code>&lt;symbol&gt;</code> задано унікальний ідентифікатор.
        </p>
        <p>
          Для використання іконки зі спрайту в HTML-документі необхідно додати
          розмітку елемента <code>&lt;svg&gt;</code> і вкладеного в нього
          елемента <code>&lt;use&gt;</code> з атрибутом <code>href</code>, в
          якому вказаний шлях до іконки. Шлях задається як до звичайного файлу,
          але наприкінці додається якір з ідентифікатором символу в спрайті.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-xml"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-tag">&lt;<span class="hljs-name">svg</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">use</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"./шлях-до-svg-спрайту/имʼя-спрайта.svg#ідентифікатор-символа"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">use</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">svg</span>&gt;</span></pre>
        </div>
      </div> -->
<!--Псевдоелементи-->
<!-- <h2>Псевдоелементи</h2>
      <div>
        <p>
          <em
            >Декоративні ефекти - це не завжди зображення або щось надзвичайно
            яскраве. Вони можуть бути досить лаконічними елементами, наприклад,
            крапки або лапки на зображенні нижче.</em
          >
        </p>
        <img src="./images/modul_4/before-block.jpg" alt="before-block" />
        <p>
          <em
            >Два приклади вище мають між собою спільну рису. Обидва потребують
            розташування декоративного елемента чітко перед та після елемента. А
            для цього маємо використовувати псевдоелементи.&nbsp;</em
          >
        </p>
        <p>
          <strong class="ql-size-large">Псевдоелементи ::before ::after</strong>
        </p>
        <p>
          Псевдоелементи використовуються для додавання декоративних ефектів без
          необхідності створення додаткових порожніх тегів у розмітці.
        </p>
        <img
          src="./images/modul_4/before and after.png"
          alt="::before and ::after"
        />
        <ul>
          <li>
            <code>::before</code> - створює псевдоелемент
            <strong>перед</strong> всім вмістом елемента (на початку).
          </li>
          <li>
            <code>::after</code> - створює псевдоелемент
            <strong>після</strong> всього вмісту елемента (наприкінці).
          </li>
        </ul>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-pgsql"
            spellcheck="false"
            data-highlighted="yes"
          >.box {
  <span class="hljs-comment">/* стилі елемента */</span>
}
        
.box::<span class="hljs-keyword">before</span> {
  <span class="hljs-comment">/* стилі псевдоелемента before */</span>
}
        
.box::<span class="hljs-keyword">after</span> {
  <span class="hljs-comment">/* стилі псевдоелемента after */</span>
}</pre>
        </div>
        <pre class="ql-blockquote" spellcheck="false">
За замовчуванням псевдоелементи — це рядкові елементи. Для того, щоб задати псевдоелементу вертикальну геометрію, необхідно змінити його тип на блоковий або рядково-блоковий.</pre
        >
        <p>
          Коли трапилася ситуація: “я все зробив, але псевдокласи не працюють”.
          Перевір чи використали властивість
          <code>content</code>. Найчастіше справа саме в цьому.&nbsp;
        </p>
        <p><strong class="ql-size-large">Властивість content</strong></p>
        <p>
          <strong>Властивість content </strong>дозволяє додати текстовий контент
          всередину псевдоелемента. Ця властивість є обов’язковою, без неї
          браузер просто не створить псевдоелемент. Якщо за макетом текстовий
          контент не потрібний, його значенням необхідно поставити порожній
          рядок.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-applescript"
            spellcheck="false"
            data-highlighted="yes"
          >&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"box"</span>&gt;
  Lorem, ipsum dolor sit amet consectetur adipisicing elit. Officia itaque quia
  nobis fugit amet adipisci, corrupti animi, iusto eius a sed totam voluptas
  porro. Dolorem aliquid rerum magnam eligendi aspernatur.
&lt;/<span class="hljs-keyword">div</span>&gt;</pre>
        </div>
        <p>
          У селекторі можна використовувати лише один псевдоелемент, який має
          додаватись після простого селектора (тега, класу, ідентифікатора).
        </p>
        <p>
          Якщо потрібно встановити загальні стилі для <code>before</code> і
          <code>after</code>, створіть окреме правило з перерахуванням
          селекторів.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          >❌ <span class="hljs-comment">/* Некоректно оформлені загальні стилі */</span>
  <span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">::before</span><span class="hljs-selector-pseudo">::after</span> {
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">30px</span>;
  }
          
  <span class="hljs-comment">/* Коректно */</span>
          
  <span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">::before</span> {
    <span class="hljs-attribute">content</span>: <span class="hljs-string">'Цей текст у before'</span>;
    <span class="hljs-attribute">color</span>: orange;
  }
          
  <span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">::after</span> {
    <span class="hljs-attribute">content</span>: <span class="hljs-string">'Цей текст у after'</span>;
    <span class="hljs-attribute">color</span>: teal;
  }
          
✅ <span class="hljs-comment">/* Коректно оформлені загальні стилі */</span>
  <span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">::before</span>, <span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">::after</span> {
    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">30px</span>;
  }</pre>
        </div>
        <p>
          Не використовуйте псевдоелементи для додавання текстового вмісту. Вони
          служать виключно для створення декоративних ефектів. Текст усередині
          псевдоелемента не сприймається асистивними технологіями та пошуковими
          системами, а також буде недоступний користувачеві, якщо не
          завантажиться файл стилів.
        </p>
        <p><strong class="ql-size-large">Псевдоклас&nbsp;:hover</strong></p>
        <p>
          Для того, щоб змінити стилі псевдоелемента при події на батьківському
          елементі, наприклад, при наведенні миші, необхідно використовувати
          наступний селектор.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-comment">/* Застосувати стилі до псевдоелементу .box::before при ховері на елемент .box */</span>
  <span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:hover</span><span class="hljs-selector-pseudo">::before</span> {
    <span class="hljs-attribute">background-color</span>: green;
}
          
<span class="hljs-comment">/* Застосувати стилі до псевдоелементу .box::after при ховері на елемент .box */</span>
    <span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:hover</span><span class="hljs-selector-pseudo">::after</span> {
      <span class="hljs-attribute">background-color</span>: tomato;
}</pre>
        </div>
        <p>Порівняй відображення елемента,</p>
        <p>у стані спокою:</p>
        <img src="./images/modul_4/orange-orange.png" alt="orange-orange" />
        <p>при наведенні:</p>
        <img src="./images/modul_4/green-red.png" alt="green-red" />
      </div> -->
<!--Позиціоновані елементи-->
<!-- <h2>Позиціоновані елементи</h2>
      <div>
        <p>
          <em
            >У світі, де так багато інформації, люди найбільше цінують
            своєчасність.</em
          >
        </p>
        <p>
          <em
            >Фото товарів у яких при наведенні спливає їх опис. Меню закріплене
            в одному куті екрану, щоб користувач завжди міг швидко його знайти.
            Сповіщення про акції, що відображаються прямо на карточці товару.
            Все це зручно для відвідувачів і вигідно для клієнтів.</em
          >
        </p>
        <p><em>Отже, розробник має вміти швидко реалізовувати ці кейси.</em></p>
        <p>
          <strong>Властивість</strong><span class="ql-size-large"> </span
          ><code>position</code>
        </p>
        <p>
          За замовчуванням елементи на сторінці розміщуються зліва направо та
          зверху вниз. Якщо треба розташувати один елемент поверх іншого,
          використовується властивість&nbsp;<code>position</code>. Вона дозволяє
          буквально підняти елемент і розмістити його поверх будь-якого іншого.
        </p>
        <p>
          Властивість <code>position</code> змінює тип позиціонування елемента.
        </p>
        <p>Є кілька основних значень властивості <code>position</code> :</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-coq"
            spellcheck="false"
            data-highlighted="yes"
          >position: static | <span class="hljs-type">relative</span> | <span class="hljs-type">absolute</span> | <span class="hljs-type">fixed</span> | <span class="hljs-type">sticky</span> </pre>
        </div>
        <img src="./images/modul_4/position.png" alt="position" />
        <p>За замовчуванням встановлено значення <code>static</code>.</p>
        <p>
          Статичне позиціонування (<code>static</code>) – це вихідний стан всіх
          елементів веб-сторінки. Блокова модель і флексбокс мають елементи саме
          в цьому статичному потоці сторінки.
        </p>
        <pre class="ql-blockquote" spellcheck="false">
Переважна більшість елементів повинна бути розміщена відповідно до стандартного статичного потоку сторінки. Інші схеми позиціонування використовуються для декоративних ефектів у разі, коли спозиціонувати іншим способом неможливо.</pre
        >
        <p>
          Елемент, значення властивості&nbsp;<code>position</code>&nbsp;якого
          відрізняється від&nbsp;<code>static</code>, називається
          <strong>«позиціонований елемент»</strong>.
        </p>
        <img
          src="./images/modul_4/Positioned elements.png"
          alt="Positioned elements"
        />
        <p>
          Відносне (<code>relative</code>), абсолютне (<code>absolute</code>) та
          фіксоване (<code>fixed</code>) позиціонування дозволяють підняти
          елемент над потоком сторінки та вручну його позиціонувати,
          використовуючи систему координат. Початок цієї системи координат
          залежить від типу позиціонування.
        </p>
        <p>
          Щоб вказати положення елемента, потрібно використати властивості
          <code>top</code>, <code>left</code>, <code>bottom</code> або
          <code>right</code>, які не застосовні до елементів без
          <code>position</code>.
        </p>
        <p>
          <strong class="ql-size-large">Відносне позиціонування</strong>
          (<code>relative</code>)
        </p>
        <p>
          При відносному позиціонуванні елемент залишається у потоці сторінки,
          тобто сусідні елементи не займають його місце. Проте візуально елемент
          можна змістити щодо його первісного&nbsp;положення. При цьому він може
          перекривати сусідів.
        </p>
        <img
          src="./images/modul_4/relative positioning.png"
          alt="relative positioning"
        />
        <p>
          Властивості&nbsp;<code>top</code>,&nbsp;<code>left</code>,&nbsp;<code>bottom</code>&nbsp;і&nbsp;<code>right</code>&nbsp;дозволяють
          вказувати візуальне зміщення елемента відносно його вихідного
          положення. Можуть мати негативне значення.
        </p>
        <img
          src="./images/modul_4/relative element.png"
          alt="relative element"
        />
        <pre class="ql-blockquote" spellcheck="false">
Окремо відносне позиціонування не використовується через те, що елемент не вилучається з потоку сторінки, продовжуючи займати місце. Отже, відносне позиціонування використовується лише у зв'язці з абсолютним позиціонуванням.</pre
        >
        <p>
          Досить часто буває, що елемент має бути “прикріпленим” до певного
          елемента. Скажімо, текстовий опис прикріплений до зображення картки
          товару.&nbsp;
        </p>
        <p>
          <strong class="ql-size-large">Абсолютне позиціонування</strong>
          (<code>absolute</code>)
        </p>
        <p>
          Абсолютне позиціонування дає зовсім інші результати порівняно з
          відносним.
        </p>
        <ol>
          <li>
            При абсолютному позиціонуванні елемент вилучається з потоку
            сторінки, тобто сусідні елементи займають його місце.
          </li>
          <li>
            За допомогою властивостей
            <code>top</code
            >,&nbsp;<code>left</code>,&nbsp;<code>bottom</code>&nbsp;і
            <code>right</code> можна налаштувати положення елемента, але треба
            обов’язково враховувати, звідки ведеться відлік значень цих
            властивостей.
          </li>
          <li>
            Щоб визначити точку відліку, браузер шукає найближчий
            елемент-предок, у якого властивість <code>position</code> має
            будь-яке значення крім <code>static</code>. Якщо такого предка не
            виявиться, то відлік буде починатися від рамки елемента
            <code>&lt;body&gt;</code>.
          </li>
        </ol>
        <img
          src="./images/modul_4/absolute positioning.png"
          alt="absolute positioning"
        />
        <p>Саме по собі абсолютне позиціонування не має великої користі.</p>
        <p>
          Зазвичай, воно використовується у зв'язці з відносним для
          декоративного позиціонування елементів. Тобто елемент «абсолютно»
          позиціонується «відносно» якогось свого предка, який знаходиться в
          потоці сторінки.
        </p>
        <img
          src="./images/modul_4/relatively absolute positioning.png"
          alt="relatively absolute positioning"
        />
        <p>
          У цьому випадку
          значення&nbsp;<code>top</code>,&nbsp;<code>left</code>,&nbsp;<code>bottom</code>&nbsp;і
          <code>right</code> для абсолютно позиціонованого елемента
          відраховуються від рамки цього предка, а не
          від&nbsp;<code>&lt;body&gt;</code>. Отже, position: relative предка ми
          використовуємо тільки для того, щоб абсолютно позиціонований елемент
          розташовувався відносно цього предка.
        </p>
        <pre
          class="ql-blockquote"
          spellcheck="false"
        >Запис <code>bottom: 20px</code> означає відстань між нижньою межею відносно позиціонованого предка і нижньою межею абсолютно позиціонованого елемента. Аналогічно працюють&nbsp;<code>right</code>,&nbsp;<code>left</code>&nbsp;і&nbsp;<code>top</code> - задається відстань між однойменними сторонами предка та елемента.</pre>
        <p>
          <strong class="ql-size-large">Фіксоване позиціонування</strong>
          (<code>fixed</code>)
        </p>
        <p>
          При фіксованому позиціонуванні елемент має значення
          <code>position: fixed</code>. Такий елемент вилучається із потоку
          сторінки та позиціонується відносно в'юпорту. Це створює ефект
          фіксації елемента у певному місці екрана під час прокручування
          сторінки.
        </p>
        <img
          src="./images/modul_4/fixed positioning.png"
          alt="fixed positioning"
        />
        <p>
          Фіксоване позиціонування використовується для закріплених хедерів з
          навігацією, вікон, чатів з менеджером на сторінках інтернет-магазинів,
          тощо.
        </p>
        <img src="./images/modul_4/I am FIXED.gif" alt="I am FIXED" />
        <p>
          <strong class="ql-size-large">Липке позиціонування</strong>
          (<code>sticky</code>)
        </p>
        <p>
          Липке позиціонування (<code>position: sticky</code>) - це комбінація
          властивостей <code>relative</code> і <code>fixed</code>. Подивись на
          гіфку, на якій липке позиціонування задається елементам з літерами A і
          B, так відразу стане зрозуміло.
        </p>
        <img
          src="./images/modul_4/position sticky.gif"
          alt="position: sticky"
        />
        <ol>
          <li>
            Поки елемент знаходиться у своєму контейнері, і контейнер не
            виходить з області видимості при вертикальному прокручуванні —
            елемент поводиться як позиціонований відносно
            (<code>relative</code>).
          </li>
          <li>
            Як тільки частина батьківського контейнера виходить із області
            видимості, елемент фіксується на сторінці до тих пір, поки хоча б
            якась частина контейнера присутня на екрані.
          </li>
          <li>
            Якщо весь контейнер вийде з області видимості, то знову увімкнеться
            поведінка як при відносному позиціонуванні — елемент зникне з екрану
            за контейнером.
          </li>
        </ol>
        <p>Для реалізації липкого позиціонування необхідні лише три умови:</p>
        <ul>
          <li>
            Липкому елементу необхідно задати позиціонування
            <code>position: sticky</code>.
          </li>
          <li>
            У липкого елемента має бути задане положення, наприклад,
            <code>top: 0</code>.
          </li>
          <li>
            Елемент-контейнер має бути більшим за висотою, ніж липкий елемент.
          </li>
        </ul>
        <p><strong class="ql-size-large">Властивість z-index</strong></p>
        <p>
          До початку вивчення позиціонованих елементів нам не доводилося
          стикатися з проблемами глибини. Ми розташовували елементи в
          двовимірній системі координат — <code>x</code> по горизонталі і
          <code>y</code> по вертикалі. Порядок відображення задавався виключно
          вкладеністю елементів — предок розташовувався внизу, подібно до аркуша
          паперу, а нащадок — немов новий аркуш паперу, який лягає зверху.
        </p>
        <p>
          Позиціоновані елементи поводяться інакше. Вони випадають з потоку, а
          значить для них потрібно правило, яке визначатиме який елемент
          знаходиться вище, а який нижче на осі <code>z</code> (осі, що
          перпендикулярна до площини екрану).
        </p>
        <p>
          Це правило задає властивість <code>z-index</code>, яке контролює
          глибину (порядок) позиціонованих елементів на сторінці по осі
          <code>z</code> від очей користувача і до екрану. У якості значення
          може бути будь-яке ціле число, у тому числі негативне.
        </p>
        <img
          src="./images/modul_4/position z-index.png"
          alt="position z-index"
        />
        <p>
          Загальний предок позиціонованих елементів створює
          <strong>контекст</strong> (stacking context) — область, в якій
          властивість <code>z-index</code> елемента впливає на інші елементи
          <code>z-index</code>.
        </p>
        <p>Що треба знати при використанні <code>z-index</code>:</p>
        <ol>
          <li>
            Чим більше значення <code>z-index</code> всередині цього контексту,
            тим вище розташовується елемент.
          </li>
          <li>
            Мінімальне (навіть негативне) значення <code>z-index</code> говорить
            про те, що інші елементи поза потоком будуть розташовані вище цього
            елементу.&nbsp;
          </li>
          <li>
            Якщо у двох елементів однакові значення <code>z-index</code>, вищим
            буде елемент, оголошений останнім у HTML-коді.
          </li>
        </ol>
        <img
          src="./images/modul_4/z-index position.png"
          alt="z-index position"
        />
        <p>
          <strong>Порівняй значення властивості </strong
          ><code><strong>z-index</strong></code
          ><strong> у живому прикладі та у відображенні в браузері</strong>
        </p>
        <img
          src="./images/modul_4/position z-index exempel.png"
          alt="position z-index exempel"
        />
      </div> -->
<!--CSS-переходи-->
<!-- <h2>CSS-переходи</h2>
      <div>
        <p><strong class="ql-size-large">Що таке CSS-перехід?</strong></p>
        <p>
          CSS-переходи дозволяють анімувати зміну значення властивостей,
          задавати час та керувати швидкістю цього переходу. Зміна властивостей
          відбувається при певній події, наприклад: <code>:hover</code>.
        </p>
        <p>
          Перехід завжди має тільки два стани: 1) початкове і 2) кінцеве
          значення властивості, і вміє змінювати це значення
          <code>A &gt; B</code> і <code>B &gt; A</code> за вказаний час.
        </p>
        <p>
          Для анімацій, де кількість станів перевищує 2, необхідно
          використовувати анімацію CSS.
        </p>
        <img src="./images/modul_4/CSS-перехід.png" alt="CSS-перехід" />
        <p>Наступні чотири властивості керують різними параметрами переходу.</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-xml"
            spellcheck="false"
            data-highlighted="yes"
          >transition-property: <span class="hljs-tag">&lt;<span class="hljs-name">властивість</span>&gt;</span>
transition-duration: <span class="hljs-tag">&lt;<span class="hljs-name">час</span>&gt;</span>
transition-timing-function: <span class="hljs-tag">&lt;<span class="hljs-name">функція</span> <span class="hljs-attr">розподілу</span> <span class="hljs-attr">часу</span>&gt;</span>
transition-delay: <span class="hljs-tag">&lt;<span class="hljs-name">затримка</span>&gt;</span></pre>
        </div>
        <p>У цьому блоці ми детально розберемо кожне з них.</p>
        <p>Все, що необхідно зробити для налаштування переходу, це:</p>
        <ol>
          <li>
            Вказати початкові значення властивостей, що анімуються, і значення
            властивостей переходу.
          </li>
          <li>
            Після чого при події, наприклад,&nbsp;<code>:hover</code>, задати
            нові значення властивостей, до яких ми хочемо анімувати елемент.
          </li>
        </ol>
        <p>
          <strong class="ql-size-large"
            >Властивість <code>transition-property</code></strong
          >
        </p>
        <p>
          Властивість <code>transition-property</code> задає властивості, до
          яких буде застосовано ефект переходу. Значенням може бути одна
          властивість або список властивостей через кому.
        </p>
        <p>
          Значення за замовчуванням — <code>all</code>, тобто анімуються всі
          можливі властивості.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-maxima"
            spellcheck="false"
            data-highlighted="yes"
          >.<span class="hljs-built_in">box</span> {
  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: teal;
  transition-property: <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>;
}
        
.<span class="hljs-built_in">box</span>:hover {
  <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: orange;
}</pre>
        </div>
        <pre
          class="ql-blockquote"
          spellcheck="false"
        ><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties" rel="noopener noreferrer" target="_blank">Список властивостей, які можуть бути анімовані, в майбутньому може змінитися.</a> Тому обов'язково необхідно вказувати властивість, яку потрібно анімувати, інакше будуть анімовані всі можливі властивості елемента, що призведе до несподіваних результатів.</pre>
        <p>
          <span style="color: rgb(55, 53, 47)"
            >Якщо потрібно задати більш ніж одну властивість, то вони вказуються
            через кому.</span
          >
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-selector-class">.box</span> {
  <span class="hljs-attribute">color</span>: orange;
  <span class="hljs-attribute">background-color</span>: teal;
  <span class="hljs-attribute">transition-property</span>: color, background-color;
}
        
<span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:hover</span> {
  <span class="hljs-attribute">background-color</span>: orange;
  <span class="hljs-attribute">color</span>: white;
}</pre>
        </div>
        <p>
          <strong class="ql-size-large"
            >Властивість <code>transition-duration</code></strong
          >
        </p>
        <p>
          Якщо тривалість переходу не вказана, зміна значень відбудеться
          миттєво, без анімації.
          Властивість&nbsp;<code>transition-duration</code>&nbsp;задає проміжок
          часу, протягом якого має здійснитися перехід.
        </p>
        <p>Значення властивості вказується в:</p>
        <ul>
          <li>секундах: <code>2s</code>&nbsp;або&nbsp;<code>0.5s</code></li>
          <li>
            мілісекундах: <code>2000ms</code>&nbsp;або&nbsp;<code>500ms</code>
          </li>
        </ul>
        <p>
          Якщо різні властивості мають різні значення часу переходу, всі вони
          перераховуються через кому.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-selector-class">.box</span> {
  <span class="hljs-attribute">background-color</span>: teal;
  <span class="hljs-attribute">transition-property</span>: background-color;
  <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">1000ms</span>;
}
        
<span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:hover</span> {
  <span class="hljs-attribute">background-color</span>: orange;
}</pre>
        </div>
        <p>
          <strong class="ql-size-large"
            >Властивість <code>transition-timing-function</code></strong
          >
        </p>
        <p>
          Властивість <code><strong>transition-timing-function</strong></code
          ><strong> </strong>задає функцію розподілу часу, тобто поведінку
          анімації.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-selector-class">.box</span> {
  <span class="hljs-attribute">background-color</span>: teal;
  <span class="hljs-attribute">transition-property</span>: background-color;
  <span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">1000ms</span>;
  <span class="hljs-attribute">transition-timing-function</span>: linear;
}
        
<span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:hover</span> {
  <span class="hljs-attribute">background-color</span>: orange;
}</pre>
        </div>
        <p>
          Значення властивості задається через формулу Безьє, яка описує
          швидкість переходу властивості від одного значення до іншого за час,
          зазначений в <code>transition-duration</code>,
        </p>
        <p>
          У CSS є кілька ключових слів для опису базових функцій Безьє, що часто
          використовуються.
        </p>
        <p>Ключові слова:</p>
        <ul>
          <li>
            <code>ease</code> - перехід починається повільно, швидко
            прискорюється, а потім знову сповільнюється в кінці.
          </li>
          <li><code>linear</code> - перехід має рівномірну швидкість.</li>
          <li>
            <code>ease-in</code> - починається повільно, швидкість переходу
            збільшується до повного завершення переходу.
          </li>
          <li>
            <code>ease-out</code> - починається швидко, уповільнюється протягом
            переходу.
          </li>
          <li>
            <code>ease-in-out</code> - починається повільно, прискорюється, а
            потім знову сповільнюється.
          </li>
        </ul>
        <p>За замовчуванням використовується значення <code>ease</code>.</p>
        <p>
          <strong class="ql-size-large"
            >Властивість <code>transition-delay</code></strong
          >
        </p>
        <p>
          Властивість <code>transition-delay</code> визначає затримку, після
          якої розпочинається анімація переходу. За замовчуванням встановлено
          значення <code>0s</code>.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-attribute">transition-delay</span>: значення;</pre>
        </div>
        <p>
          <strong class="ql-size-large"
            >Властивість <code>transition</code></strong
          >
        </p>
        <p>
          Всі властивості переходу можна поєднати в одну складову властивість
          <code>transition</code>.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-inform7"
            spellcheck="false"
            data-highlighted="yes"
          >transition: <span class="hljs-comment">[property]</span> <span class="hljs-comment">[duration]</span> <span class="hljs-comment">[timing-function]</span> <span class="hljs-comment">[delay]</span></pre>
        </div>
        <p>
          Якщо анімується кілька властивостей, то набір значень кожної з них
          розділяється комою.
        </p>
        <p>Необхідно обов'язково вказати властивість та час переходу.</p>
        <p>
          Функцію часу та затримку можна не вказувати — тоді для них буде
          використано значення за замовчуванням.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-maxima"
            spellcheck="false"
            data-highlighted="yes"
          >transition: <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span> 500ms <span class="hljs-built_in">linear</span>, <span class="hljs-built_in">transform</span> 500ms ease-<span class="hljs-keyword">in</span>-out;</pre>
        </div>
      </div> -->
<!--2D-трансформації-->
<!-- <h2>2D-трансформації</h2>
      <div>
        <p>
          <em
            >CSS-переходи, CSS-анімації, а тепер ще й 2D трансформації. Як це
            все розрізняти?</em
          >
        </p>
        <p>
          <em
            >CSS-переходи і CSS-анімації відрізняються кількістю налаштованих
            станів. 2D-трансформації — це зовсім інша справа. Вони не про “</em
          ><strong><em>як”</em></strong
          ><em> (2 стани чи багато кадрів), а про то “</em
          ><strong><em>які властивості”</em></strong
          ><em> змінюються.</em>
        </p>
        <p>
          <em
            >2D-трансформації змінюють елементи у двовимірному просторі та
            можуть використовуватися і в CSS-переходах, і в CSS-анімації. А ще
            вони добре сприймаються браузером!</em
          >
        </p>
        <p><strong class="ql-size-huge">Масштабування</strong></p>
        <p>
          CSS-трансформації дозволяють зміщувати, повертати елементи та
          змінювати їх масштаб — тобто додавати декоративні ефекти.
          Трансформації змінюють форму та положення елемента, не впливаючи на
          інші елементи сторінки. За замовчуванням трансформація відбувається
          відносно центру елемента.
        </p>
        <p>
          Властивість <code>transform</code> відповідає за застосування однієї
          або більше трансформацій елемента.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-pf"
            spellcheck="false"
            data-highlighted="yes"
          >transform: <span class="hljs-keyword">none</span> | <span class="hljs-variable">&lt;тип трансформації&gt;</span> <span class="hljs-variable">&lt;тип трансформації&gt;</span> ...</pre>
        </div>
        <p>
          <strong>Трансформований елемент</strong> - це елемент, що має будь-яке
          значення властивості <code>transform</code>, відмінне від
          <code>none</code>.
        </p>
        <p>
          Функції <code>scaleX(tx)</code>, <code>scaleY(ty)</code> і
          <code>scale(tx, ty)</code> масштабують блок по ширині та/або висоті,
          не впливаючи на геометрію навколишніх елементів. Якщо для
          <code>scale()</code> задано певне значення, друге буде таким самим.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-selector-class">.box</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.15</span>);
}</pre>
        </div>
        <p>Початковий масштаб елемента - <code>1</code>.</p>
        <p>
          Значення від <code>1</code> до <code>0</code> зменшують елемент.
          Значення більше ніж <code>1</code>, навпаки, збільшують.
        </p>
        <p>
          Наприклад, значення&nbsp;<code>scale(1.25)</code>&nbsp;— це 125% від
          початкового розміру, а&nbsp;<code>scale(0.75)</code>&nbsp;— 75%.
        </p>
        <pre
          class="ql-blockquote"
          spellcheck="false"
        >З усіх <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_animated_properties" rel="noopener noreferrer" target="_blank">властивостей, які можуть бути анімовані,</a> рекомендується, по можливості, використовувати всього дві: <code>opacity</code> (прозорість) і <code>transform</code> (трансформація). У більшості випадків анімація інших властивостей значно не вплине на продуктивність сторінки, але краще дотримуватися цього правила, щоб створювати максимально продуктивну анімацію.</pre>
        <p><strong class="ql-size-large">Поворот</strong></p>
        <p>
          Функція&nbsp;<code>rotate(кут)</code>&nbsp;повертає елементи на задану
          кількість градусів (одиниця&nbsp;<code>deg</code>). Позитивні значення
          повертають елемент за годинниковою стрілкою, негативні — проти.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-selector-class">.box</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">45deg</span>);
}</pre>
        </div>
        <p>
          Значення можна передати не лише в градусах, а й в «обертах» (одиниця
          <code>turn</code>). Наприклад, <code>rotate(0.5turn)</code> — це
          півоберту, аналог <code>rotate(180deg)</code>.
        </p>

        <iframe
          src="https://codepen.io/goit-academy/embed/BajPxRa?default-tab=css,result"
          class="ql-custom-iframe"
          id="q9ops"
          allowfullscreen="true"
          groupid="35474143"
          courseid="17039071"
          moduleid="17039127"
          block="[object Object]"
          element="[object Object]"
          userinfo="[object Object]"
        ></iframe>
        <p><strong class="ql-size-huge">Зміщення</strong></p>
        <p>
          Функції&nbsp;<code>translateX(tx)</code>,&nbsp;<code>translateY(ty)</code>&nbsp;і&nbsp;<code
            >translate(tx, ty)</code
          >&nbsp;переміщають елемент у
        </p>
        <p>
          горизонтальному (вісь X) та/або вертикальному (вісь Y) напрямках щодо
          початкового положення.
        </p>
        <ul>
          <li>
            Позитивні значення X зміщують елемент праворуч, негативні — ліворуч.
          </li>
          <li>
            Позитивні значення Y зміщують елемент вниз, негативні — вгору.
          </li>
        </ul>
        <img src="./images/modul_4/Frame 48414.jpg" alt="Frame" />
        <p>
          Значення можуть бути у пікселях чи відсотках. Якщо значення задано у
          відсотках, воно розраховується від розміру зміщуваного елемента.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-selector-class">.box</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">100px</span>, <span class="hljs-number">200px</span>);
}</pre>
        </div>

        <iframe
          src="https://codepen.io/goit-academy/embed/OJMwzYX?default-tab=css,result"
          class="ql-custom-iframe"
          id="0i70t"
          allowfullscreen="true"
          groupid="35474143"
          courseid="17039071"
          moduleid="17039127"
          block="[object Object]"
          element="[object Object]"
          userinfo="[object Object]"
        ></iframe>
        <p><strong class="ql-size-large">Декоративний оверлей</strong></p>
        <p>
          Зміщення та властивість&nbsp;<code>overflow</code> зі
          значенням&nbsp;<code>hidden</code> використовуються при створенні
          декоративних ефектів з появою прихованого вмісту з-за меж блоку.
        </p>
        <p>Переглянь живий приклад, щоб побачити, як це працює у браузері.</p>
        <iframe
          src="https://codepen.io/goit-academy/embed/rNxrGMQ?default-tab=html%2Cresult"
          class="ql-custom-iframe"
          id="5pn4a"
          allowfullscreen="true"
          groupid="35474143"
          courseid="17039071"
          moduleid="17039127"
          block="[object Object]"
          element="[object Object]"
          userinfo="[object Object]"
        ></iframe>
        <p>
          Такий ефект реалізується за кілька простих кроків. Розберемо стилі для
          створення ефекту. Повний код дивись у живому прикладі.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-applescript"
            spellcheck="false"
            data-highlighted="yes"
          >&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"box"</span>&gt;
  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"overlay"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;
&lt;/<span class="hljs-keyword">div</span>&gt;</pre>
        </div>
        <p>
          Спочатку абсолютно
          позиціонуємо&nbsp;<code>div.overlay</code>&nbsp;відносно
          <code>div.box</code>&nbsp;і розтягуємо його на всю ширину і
          висоту&nbsp;<code>div.box</code>.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-selector-class">.box</span> {
  <span class="hljs-attribute">position</span>: relative;
}
        
<span class="hljs-selector-class">.overlay</span> {
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
}</pre>
        </div>
        <p>
          Використовуючи
          властивість&nbsp;<code>transform</code>&nbsp;і&nbsp;<code>translateX</code>,
          зміщуємо&nbsp;<code>div.overlay</code>&nbsp;ліворуч на 100% його
          ширини.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-selector-class">.overlay</span> {
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
        
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100%</span>);
}</pre>
        </div>
        <p>
          При ховері по&nbsp;<code>div.box</code>,
          використовуючи&nbsp;<code>transform</code>&nbsp;і&nbsp;<code>translateX</code>,
          повертаємо&nbsp;<code>div.overlay</code>&nbsp;у вихідне положення.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-stylus"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:hover</span> <span class="hljs-selector-class">.overlay</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">0</span>);
}</pre>
        </div>
        <p>
          Задаємо&nbsp;<code>div.box</code>
          властивість&nbsp;<code>overflow</code>&nbsp;зі
          значенням&nbsp;<code>hidden</code>, щоб візуально сховати&nbsp;<code
            >div.overlay</code
          >
          при зміщенні за межі&nbsp;<code>div.box</code>.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-selector-class">.box</span> {
  <span class="hljs-attribute">position</span>: relative;
  <span class="hljs-attribute">overflow</span>: hidden;
}</pre>
        </div>
        <p>
          Додаємо&nbsp;<code>div.overlay</code>&nbsp;перехід для анімації
          властивості&nbsp;<code>transform</code>, тим самим анімуємо появу
          оверлею.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-selector-class">.overlay</span> {
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;
  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;
  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;
        
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(-<span class="hljs-number">100%</span>);
  <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">250ms</span> ease-in-out;
}</pre>
        </div>
        <p><strong class="ql-size-large">Центрування елемента</strong></p>
        <p>
          Розглянемо прийом, що дозволяє розташувати абсолютно позиціонований
          елемент точно по центру блока, відносно якого він позиціонується.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-applescript"
            spellcheck="false"
            data-highlighted="yes"
          >&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"parent"</span>&gt;
  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"box"</span>&gt;&lt;/<span class="hljs-keyword">div</span>&gt;
&lt;/<span class="hljs-keyword">div</span>&gt;</pre>
        </div>
        <p>Техніка дуже проста і складається із трьох кроків.</p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-selector-class">.parent</span> {
  <span class="hljs-attribute">position</span>: relative;
}
        
<span class="hljs-selector-class">.box</span> {
  <span class="hljs-attribute">position</span>: absolute;
  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;
  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);
}</pre>
        </div>
        <ol>
          <li>Абсолютно позиціонуємо елемент відносно предка.</li>
          <li>
            Задаємо елементу
            властивості&nbsp;<code>top</code>&nbsp;і&nbsp;<code>left</code>&nbsp;зі
            значенням&nbsp;<code>50%</code>, щоб розташувати верхній лівий кут
            елемента рівно по центру предка.
          </li>
          <li>
            Задаємо елементу негативне зміщення (translate) по 50% висоти і
            ширини. Це змістить елемент вгору і вліво і відцентрує всередині
            предка.
          </li>
        </ol>
        <p>Розглянь живий приклад, щоб побачити, як це виглядає на сторінці.</p>
        <iframe
          src="https://codepen.io/goit-academy/embed/KKVBByO?default-tab=css,result"
          class="ql-custom-iframe"
          id="531wb"
          allowfullscreen="true"
          groupid="35474143"
          courseid="17039071"
          moduleid="17039127"
          block="[object Object]"
          element="[object Object]"
          userinfo="[object Object]"
        ></iframe>
        <p><strong class="ql-size-large">Викривлення</strong></p>
        <p>
          Функції&nbsp;<code>skewX(кут)</code>,&nbsp;<code>skewY(кут)</code>&nbsp;і&nbsp;<code
            >skew(x-кут, y-кут)</code
          >&nbsp;використовуються для визначення параметрів викривлення (нахилу,
          деформування) сторін елемента відносно координатних осей. Якщо
          для&nbsp;<code>skew()</code>&nbsp;вказано тільки одне значення, друге
          буде дорівнювати&nbsp;<code>0</code>, тобто це буде
          аналог&nbsp;<code>skewX()</code>.
        </p>
        <div class="ql-syntax-block">
          <pre
            class="ql-syntax hljs language-css"
            spellcheck="false"
            data-highlighted="yes"
          ><span class="hljs-selector-class">.box</span> {
  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">skew</span>(<span class="hljs-number">30deg</span>);
}</pre>
        </div>
        <iframe
          src="https://codepen.io/goit-academy/embed/oNbMqgY?default-tab=css,result"
          class="ql-custom-iframe"
          id="ckexj"
          allowfullscreen="true"
          groupid="35474143"
          courseid="17039071"
          moduleid="17039127"
          block="[object Object]"
          element="[object Object]"
          userinfo="[object Object]"
        ></iframe>
      </div> -->
<!--План виконання ДЗ 4-->
<!-- <h2>План виконання ДЗ 4</h2> -->

<!--<h2>Домашнє завдання</h2>
    </section> -->
<!--Модуль 5. Елементи форм. Доступність-->
<!-- <h1>Модуль 5. Елементи форм. Доступність</h1>
    <section>
      <h2>Програма модулю</h2>
      <h2>Форми</h2>
      <h2>Елемент input</h2>
      <h2>Елементи textarea та select</h2>
      <h2>Специфічна інформація у формах</h2>
      <h2>Елементи радіокнопка і чекбокс</h2>
      <h2>Створення модального вікна</h2>
      <h2>Домашнє завдання</h2>
    </section> -->
<!--Модуль 6. Адаптивний дизайн-->
<!-- <h1>Модуль 6. Адаптивний дизайн</h1>
    <section>
      <h2>Програма модуля</h2>
      <h2>Респонсивні сторінки</h2>
      <h2>Медіазапити</h2>
      <h2>Логічні оператори</h2>
      <h2>Підхід «Mobile First»</h2>
      <h2>Адаптивна графіка</h2>
      <h2>Домашнє завдання</h2>-->
<!-- </section>
  </body>
</html> -->
